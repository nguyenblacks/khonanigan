<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swavoti - Professional Social Network</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>
    <style>
        :root {
            --primary-color: #3a86ff;
            --secondary-color: #8338ec;
            --accent-color: #ff006e;
            --dark-color: #1a1a2e;
            --light-color: #f8f9fa;
            --gray-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #fd7e14;
            --skeleton-bg-color: #e0e0e0;
            --shimmer-color: #f0f0f0;
            --primary-color-rgb: 58, 134, 255;
            --success-color-rgb: 40, 167, 69;
            --danger-color-rgb: 220, 53, 69;
            --warning-color-rgb: 253, 126, 20;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: var(--dark-color);
            min-height: 100vh;
            padding-bottom: 0; /* Will be adjusted by media queries if bottom nav is present */
        }

        /* Skeleton Loader CSS */
        /* Updated Shimmer Effect */
        @keyframes shimmer {
          0% { left: -100%; }
          100% { left: 100%; }
        }

        .skeleton-loader { /* This will be the base for elements that need a shimmer */
            background-color: var(--skeleton-bg-color);
            border-radius: 4px;
            position: relative;
            overflow: hidden; /* Important for the shimmer effect */
        }

        .skeleton-loader.shimmer::before { /* Apply shimmer to elements with .shimmer class */
            content: "";
            position: absolute;
            top: 0;
            left: -100%; /* Start off-screen to the left */
            width: 100%;
            height: 100%;
            background: linear-gradient(
              90deg,
              transparent,
              rgba(255, 255, 255, 0.4), /* Shimmer color */
              transparent
            );
            animation: shimmer 1.5s infinite;
        }
        /* End Updated Shimmer Effect */

        .skeleton-post-card {
            background-color: white;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .skeleton-post-card .header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .skeleton-post-card .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .skeleton-post-card .user-info {
            flex-grow: 1;
        }
        .skeleton-post-card .line {
            height: 12px;
            margin-bottom: 6px;
        }
        .skeleton-post-card .line-sm {
            height: 10px;
            width: 70%;
        }
        .skeleton-post-card .media {
            height: 200px;
            border-radius: 8px;
        }
        .skeleton-post-card .actions {
            height: 20px;
            width: 60%;
        }

        .skeleton-story-item-wrapper {
            min-width: 100px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-right: 15px;
        }
        .skeleton-story-item-wrapper .avatar {
            width: 70px;
            height: 70px;
            border-radius: 50%;
        }
        .skeleton-story-item-wrapper .line {
            width: 60px;
            height: 10px;
        }

        .skeleton-reel-grid-item-wrapper {
             width: 100%;
             height: 250px;
             border-radius: 10px;
        }

        .skeleton-reel-item-wrapper {
            width: 100%;
            height: calc(100vh - 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .skeleton-reel-item-wrapper .media {
            width: 100%;
            height: 100%;
        }

        /* More Accurate Skeleton Loaders */
        .skeleton-user-list-item, .skeleton-notification-item, .skeleton-conversation-item {
            background-color: white;
            border-radius: 10px;
            margin-bottom: 10px; /* Consistent with message items */
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .skeleton-user-list-item .avatar,
        .skeleton-notification-item .avatar,
        .skeleton-conversation-item .avatar {
            width: 50px; /* Matches .message-item img, .user-list-item img */
            height: 50px;
            border-radius: 50%;
        }
        .skeleton-notification-item .avatar { /* Notifications have smaller avatar */
            width: 40px;
            height: 40px;
        }
        .skeleton-user-list-item .text-lines,
        .skeleton-notification-item .text-lines,
        .skeleton-conversation-item .text-lines {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .skeleton-user-list-item .line-md, /* Medium line for name/title */
        .skeleton-notification-item .line-md,
        .skeleton-conversation-item .line-md {
            height: 12px;
            width: 70%;
        }
        .skeleton-user-list-item .line-sm, /* Small line for subtitle/username */
        .skeleton-notification-item .line-sm,
        .skeleton-conversation-item .line-sm {
            height: 10px;
            width: 50%;
        }
        .skeleton-notification-item .line-xs { /* Extra small for notification time */
            height: 8px;
            width: 30%;
        }
        .skeleton-conversation-item .time-placeholder { /* For conversation timestamp */
            width: 40px;
            height: 10px;
            margin-left: auto; /* Push to the right */
        }


        /* Media Loading Overlay & Spinner */
        .media-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000; /* Opaque black */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
            opacity: 1;
            visibility: visible;
        }
        .media-loading-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* End Media Loading Overlay & Spinner */

        /* New Authentication Page CSS */
        body.auth-active { /* Conditional styling for body when auth is active */
          font-family: 'Segoe UI', sans-serif;
          background: linear-gradient(to right, #111928, #1e3a8a);
          margin: 0;
          padding: 0; /* Ensure no padding interferes with centering */
          display: flex;
          height: 100vh; /* Full viewport height */
          justify-content: center;
          align-items: center;
          overflow: hidden; /* Prevent scrollbars on auth page */
        }

        /* Styles for the new auth page, targeting .auth-inner-container */
        .auth-inner-container {
          background: #fff;
          padding: 2rem;
          width: 100%;
          max-width: 420px;
          border-radius: 20px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          animation: slideUp 0.5s ease;
          /* Remove display:flex and min-height:100vh from here if body.auth-active handles it */
        }

        @keyframes slideUp {
          from {
            transform: translateY(30px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }

        .auth-inner-container .logo { /* Scoped to new auth container */
          text-align: center;
          margin-bottom: 1rem;
        }

        .auth-inner-container .logo img {
          width: 80px;
          height: 80px;
          object-fit: cover;
          border-radius: 50%;
        }

        .auth-inner-container .tab-buttons {
          display: flex;
          justify-content: space-between;
          margin-bottom: 1.5rem;
        }

        .auth-inner-container .tab-buttons button {
          flex: 1;
          padding: 10px;
          border: none;
          background: #e5e7eb;
          cursor: pointer;
          font-weight: bold;
          border-radius: 8px;
          transition: 0.3s;
          margin: 0 5px; /* Add small margin between tab buttons */
        }
        .auth-inner-container .tab-buttons button:first-child { margin-left: 0; }
        .auth-inner-container .tab-buttons button:last-child { margin-right: 0; }


        .auth-inner-container .tab-buttons button.active {
          background: #1e3a8a;
          color: #fff;
        }

        .auth-inner-container form { /* Scoped to new auth container */
          display: none;
          flex-direction: column;
        }

        .auth-inner-container form.active { /* Scoped */
          display: flex;
        }

        .auth-inner-container input[type="text"],
        .auth-inner-container input[type="email"],
        .auth-inner-container input[type="password"] { /* Scoped */
          padding: 12px;
          margin: 8px 0;
          border: 1px solid #ccc;
          border-radius: 10px;
        }

        .auth-inner-container .checkbox-container { /* Scoped */
          display: flex;
          align-items: center;
          margin-top: 10px;
        }

        .auth-inner-container .checkbox-container input { /* Scoped */
          margin-right: 8px;
        }

        .auth-inner-container .checkbox-container label { /* Scoped */
          font-size: 0.9rem;
        }

        .auth-inner-container .checkbox-container a { /* Scoped */
          color: #1e3a8a;
          text-decoration: none;
          font-weight: bold;
        }

        .auth-inner-container button.submit-btn { /* Scoped */
          margin-top: 1rem;
          padding: 12px;
          background: #1e3a8a;
          color: white;
          border: none;
          border-radius: 10px;
          cursor: pointer;
          font-weight: bold;
          transition: background 0.3s ease;
          position: relative; /* For spinner positioning */
        }

        .auth-inner-container button.submit-btn:disabled { /* Scoped */
          background: #94a3b8;
          cursor: not-allowed;
        }
        
        /* Spinner for new auth buttons */
        .auth-inner-container button.submit-btn .spinner {
            border: 3px solid rgba(255, 255, 255, 0.4); /* Adjusted for new button color */
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 18px; /* Match previous spinner */
            height: 18px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }


        .auth-inner-container .link { /* Scoped */
          margin-top: 12px;
          text-align: center;
          font-size: 0.9rem;
        }

        .auth-inner-container .link a { /* Scoped */
          color: #1e3a8a;
          text-decoration: none;
          font-weight: 500;
        }
        /* End New Authentication Page CSS */

        /* Main App */
        #app-container {
            display: none; /* Controlled by JS */
            width: 100%; /* Ensure it takes full width when visible */
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar - Desktop */
        .sidebar {
            width: 250px;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            z-index: 100;
            display: none; /* Controlled by media query */
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 30px;
            padding: 0 20px;
        }

        .logo span {
            color: var(--secondary-color);
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 5px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: var(--dark-color);
            text-decoration: none;
            /* transition: all 0.3s; /* Removed for fixed nav */
        }

        .nav-link:hover, .nav-link.active {
            background-color: rgba(58, 134, 255, 0.1);
            color: var(--primary-color);
            border-left: 3px solid var(--primary-color);
        }

        .nav-link i {
            margin-right: 10px;
            font-size: 20px;
        }

        .create-post-btn {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: 30px;
            padding: 12px 20px;
            margin: 20px;
            width: calc(100% - 40px);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            /* transition: all 0.3s; /* Removed for fixed nav */
        }

        .create-post-btn:hover {
            /* transform: translateY(-2px); /* Optional: keep for interaction */
            /* box-shadow: 0 5px 15px rgba(58, 134, 255, 0.3); /* Optional: keep for interaction */
            opacity: 0.9; /* Simpler hover effect */
        }

        .create-post-btn i {
            margin-right: 8px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding-top: 60px; /* Height of the fixed header */
            padding-left: 20px;
            padding-right: 20px;
            padding-bottom: 60px; /* Space for bottom nav on mobile, adjusted by media query */
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 999;
            height: 60px;
            box-sizing: border-box;
            /* border-radius: 0; /* Removed, was in mobile query */
            /* transition: none; /* Explicitly no transition */
        }

        @media (min-width: 992px) {
            .header {
                left: 250px;
                width: calc(100% - 250px);
            }
             .main-content {
                padding-top: 60px; /* Match header height */
                padding-bottom: 20px; /* Reset bottom padding for desktop */
            }
        }

        @media (max-width: 991px) { /* Covers tablets and mobile */
            .main-content {
                 padding-top: 60px; /* Match header height */
                 padding-bottom: 60px; /* Space for bottom nav */
            }
        }

        @media (max-width: 767px) { /* Mobile specific adjustments for header and main content */
            .header {
                border-radius: 0;
            }
            .main-content {
                 padding-top: 60px; /* Match header height */
                 /* padding-bottom: 60px; /* Already set by max-width: 991px */
            }
        }


        .search-bar {
            position: relative;
            width: 40%;
        }

        .search-bar input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border: 1px solid #ddd;
            border-radius: 30px;
            outline: none;
            transition: all 0.3s;
        }

        .search-bar input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(58, 134, 255, 0.2);
        }

        .search-bar i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray-color);
        }

        .user-actions {
            display: flex;
            align-items: center;
        }

        .search-icon-mobile, .notification-icon, .message-icon {
            position: relative;
            margin-right: 20px;
            cursor: pointer;
        }
        .search-icon-mobile {
            display: none; /* Hidden by default, shown on mobile */
        }

        .notification-icon i, .message-icon i, .search-icon-mobile i {
            font-size: 20px;
            color: var(--gray-color);
        }

        .notification-count, .message-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--danger-color);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .user-profile {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .user-profile img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .user-profile span {
            font-weight: 600;
        }

        /* Content Area */
        .content-area {
            display: flex;
            gap: 20px;
        }

        .feed {
            flex: 1;
        }

        .sidebar-right {
            flex: 1;
        }

        /* Post Card */
        .post-card {
            background-color: #ffffff; /* Shiny white */
            border-radius: 16px; /* Softer radius */
            margin-bottom: 25px; /* Increased spacing */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.07); /* Softer, slightly more pronounced shadow */
            border: 1px solid #f0f0f0; /* Very subtle border */
            overflow: hidden;
            transition: box-shadow 0.3s ease-in-out;
        }
        .post-card:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); /* Enhanced shadow on hover */
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px; /* Standardized padding */
            position: relative;
        }

        .post-user {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .post-user img {
            width: 45px; /* Slightly larger avatar */
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 12px; /* Adjusted margin */
        }

        .post-user-info {
            display: flex;
            flex-direction: column;
        }

        .post-user-info h4 {
            font-size: 16px; /* Increased font size */
            font-weight: 600; /* Emphasized username */
            margin-bottom: 3px; /* Adjusted spacing */
            display: flex;
            align-items: center;
            color: var(--dark-color);
        }
        .post-user-info h4 .follow-button {
            margin-left: 10px;
            padding: 5px 10px; /* Slightly larger button */
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px; /* Softer radius */
            border: 1px solid var(--primary-color);
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .post-user-info h4 .follow-button.following {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        .post-user-info h4 .follow-button:hover {
            opacity: 0.8;
            /* transform: translateY(-1px); Removed for less jumpiness */
        }

        .post-user-info p { /* Timestamp and location */
            font-size: 13px; /* Slightly larger */
            color: var(--gray-color);
        }

        .post-options {
            cursor: pointer;
            color: var(--gray-color);
            position: relative;
        }

        .post-options-dropdown {
            position: absolute;
            top: 35px;
            right: 0;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            min-width: 120px;
            display: none;
        }
        .post-options-dropdown button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: var(--dark-color);
        }
        .post-options-dropdown button:hover {
            background-color: #f0f0f0;
        }
        .post-options-dropdown button.delete-btn {
            color: var(--danger-color);
        }


        .post-content {
            padding: 0 20px 15px 20px; /* Standardized padding */
        }

        .post-text {
            margin-bottom: 15px;
            line-height: 1.6; /* Improved readability */
            font-size: 15px; /* Standardized content font size */
            color: #333; /* Darker text for better contrast */
        }

        .post-image {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
            max-height: 500px;
            object-fit: cover;
        }

        .post-video-container {
            position: relative;
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
            max-height: 500px;
            overflow: hidden;
            background-color: #1A1A1A;
        }

        .post-video {
            width: 100%;
            height: 100%;
            max-height: 500px;
            object-fit: cover;
        }

        /* Post Gallery Carousel Styles */
        .post-gallery-container {
            position: relative;
            width: 100%;
            overflow: hidden;
            border-radius: 8px; /* Match post-image */
            margin-bottom: 15px; /* Match post-image */
            background-color: #e0e0e0; /* Light background for aspect ratio consistency */
            aspect-ratio: 16 / 9; /* Default aspect ratio, adjust as needed */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .post-gallery-inner {
            display: flex;
            height: 100%;
            transition: transform 0.3s ease-in-out;
        }
        .post-gallery-image {
            width: 100%; /* Each image takes full width of the container */
            height: 100%;
            object-fit: contain; /* Changed to contain to see full image, or cover if preferred */
            flex-shrink: 0; /* Prevent images from shrinking */
        }
        .gallery-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 18px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .gallery-nav:hover {
            opacity: 1;
        }
        .gallery-nav.prev {
            left: 10px;
        }
        .gallery-nav.next {
            right: 10px;
        }
        .gallery-dots {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 10;
        }
        .gallery-dots .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .gallery-dots .dot.active {
            background-color: white;
        }


        .video-mute-button {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
        }

        .post-stats {
            display: flex;
            justify-content: space-between;
            align-items: center; /* Vertically align items */
            padding: 12px 20px; /* Standardized padding */
            border-top: 1px solid #f0f0f0; /* Lighter border */
            border-bottom: 1px solid #f0f0f0; /* Lighter border */
            color: var(--gray-color);
            font-size: 13px; /* Slightly smaller for stats */
        }
        .post-stats .post-likes, .post-stats .post-comments {
            display: flex;
            align-items: center;
            gap: 6px; /* Space between icon and text */
        }


        .post-actions {
            display: flex;
            justify-content: flex-start; /* Align to the left */
            padding: 8px 15px; /* Keep padding */
            gap: 15px; /* Add space between action items */
        }

        .post-action {
            display: flex;
            align-items: center;
            color: var(--gray-color);
            cursor: pointer;
            padding: 8px 12px; /* Consistent padding */
            border-radius: 8px; /* Softer radius */
            transition: all 0.2s ease-in-out;
            font-size: 14px; /* Standardized font size */
            font-weight: 500; /* Slightly bolder */
        }

        .post-action:hover {
            background-color: rgba(var(--primary-color-rgb, 58, 134, 255), 0.08); /* Use RGB for opacity on primary */
            color: var(--primary-color);
        }
        /* Define --primary-color-rgb in :root if not already, e.g. --primary-color-rgb: 58, 134, 255; */


        .post-action i {
            margin-right: 6px; /* Adjusted spacing */
            font-size: 18px; /* Slightly larger icons */
        }

        .post-action.liked {
            color: var(--primary-color);
            font-weight: 600; /* Emphasize liked state */
        }
        .post-action.liked i {
            font-weight: 900; /* Solid icon for liked state if using FontAwesome Pro, or use fas */
        }


        /* Reels */
        .reels-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh; /* Full viewport height */
            background-color: #1A1A1A;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            overscroll-behavior-y: contain;
            z-index: 1000;
            display: none;
            padding-bottom: 60px; /* Space for bottom nav */
        }
        .reels-header {
            position: sticky;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            z-index: 1001;
        }
        .reels-header .back-btn, .reels-header .search-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }


        .reel-item {
            width: 100%;
            height: 100vh; /* Changed to full viewport height */
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
            background-color: #1A1A1A;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reel-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .reel-actions {
            position: absolute;
            right: 15px;
            bottom: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reel-action {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        .reel-action i {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .reel-action span {
            font-size: 12px;
        }

        .reel-action.liked i {
            color: var(--primary-color);
        }

        .reel-user {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            align-items: center;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        .reel-user .follow-button {
            margin-left: 10px;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 5px;
            border: 1px solid white;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .reel-user .follow-button.following {
            background-color: transparent;
        }

        .reel-user img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid white;
        }

        .close-reels {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            z-index: 1001;
            cursor: pointer;
        }

        /* Notifications */
        .notification-item {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .notification-item:hover {
            background-color: rgba(58, 134, 255, 0.05);
        }

        .notification-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }

        .notification-content {
            flex: 1;
        }

        .notification-content p {
            margin-bottom: 5px;
        }

        .notification-time {
            font-size: 12px;
            color: var(--gray-color);
        }

        .notification-unread {
            background-color: rgba(58, 134, 255, 0.1);
        }

        /* Messages */
        .message-section {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .message-section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .message-item {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .message-item:hover {
            background-color: rgba(58, 134, 255, 0.05);
        }

        .message-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }

        .message-content {
            flex: 1;
        }

        .message-content h4 {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }

        .message-preview {
            color: var(--gray-color);
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .message-time {
            font-size: 12px;
            color: var(--gray-color);
        }

        .message-unread {
            font-weight: bold;
        }

        /* Message Filters */
        .message-filters {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 10px;
        }
        .message-filter-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            background-color: transparent;
            color: var(--gray-color);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .message-filter-btn { /* Default outlined style */
            flex: 1;
            padding: 10px 15px;
            border: 1px solid var(--primary-color); /* Outline with primary color */
            background-color: transparent; /* Transparent background */
            color: var(--primary-color); /* Text color primary */
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            margin: 0 5px; /* Add small margin between buttons */
        }
        .message-filter-btn:first-child {
            margin-left: 0;
        }
        .message-filter-btn:last-child {
            margin-right: 0;
        }

        .message-filter-btn.active { /* Active filled style */
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color); /* Ensure border color remains consistent or not needed */
        }
        .message-filter-btn:hover:not(.active) { /* Hover for inactive outlined buttons */
            background-color: rgba(var(--primary-color-rgb), 0.08); /* Subtle primary background tint */
            /* color: var(--primary-color); /* Already primary color */
        }
        .message-filter-btn:hover.active { /* Hover for active button - can make it slightly darker if needed */
            /* background-color: #0056b3; Darker shade of primary */
            /* border-color: #0056b3; */
            opacity: 0.85; /* Slightly darken the gradient on hover for active */
        }

        /* New styles for message filter buttons default state */
        .message-filters .message-filter-btn {
            background: linear-gradient(to right, var(--secondary-color), var(--primary-color)); /* Purple to Blue gradient */
            color: white;
            border: 1px solid transparent; /* Remove distinct border or match gradient edge */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .message-filters .message-filter-btn.active {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color)); /* Blue to Purple gradient for active */
            color: white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
            /* Optional: Add a more distinct visual cue for active, like a top/bottom border if needed */
            /* border-bottom: 3px solid var(--accent-color); */
        }

        .message-filters .message-filter-btn:hover:not(.active) {
             background: linear-gradient(to right, var(--primary-color), var(--secondary-color)); /* Blue to Purple gradient on hover */
             opacity: 0.9;
             box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }

        /* Style for the New Group Button */
        #newGroupBtn {
            background: linear-gradient(to right, var(--secondary-color), var(--primary-color)); /* Purple to Blue gradient */
            color: white !important; /* Ensure text color is white */
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #newGroupBtn:hover {
            opacity: 0.9;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }


        /* Chat Modal - Full Screen */
        .chat-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .chat-modal-content {
            background-color: white;
            border-radius: 0;
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            display: flex;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            background-color: var(--light-color);
        }

        .chat-header img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .chat-header h4 {
            flex-grow: 1;
            font-weight: 600;
            display: flex;
            align-items: center;
        }
        .chat-header .online-status {
            font-size: 12px;
            color: var(--gray-color);
            margin-left: 10px;
        }
        .chat-header .online-status.online {
            color: var(--success-color);
            font-weight: 600;
        }


        .close-chat-modal {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--gray-color);
        }

        .chat-messages {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            background-image: url('https://i.postimg.cc/Yqnm9TjY/Chat-GPT-Image-Jul-12-2025-08-02-03-PM.png');
            background-size: cover;
            background-position: center;
        }

        .message-bubble {
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            line-height: 1.5; /* Improved line height */
            position: relative;
            font-size: 15px; /* Standardize bubble text size */
        }

        .message-bubble.sent {
            background: linear-gradient(to right, #3a86ff, #8338ec);
            color: white;
            align-self: flex-end;
            border-radius: 20px 20px 5px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .message-bubble.received {
            background-color: #ffffff;
            color: var(--dark-color);
            align-self: flex-start;
            border-radius: 20px 20px 20px 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border: 1px solid #f0f0f0;
        }

        .message-bubble img,
        .message-bubble video { /* Combined styling for media within bubbles */
            max-width: 100%;
            border-radius: 10px;
            margin-top: 8px;
            display: block; /* Ensure they take block space if needed */
        }
        /* Ensure video controls are visible if it's a video tag directly */
        .message-bubble video {
            /* controls: auto; /* This is an HTML attribute, not CSS. JS should add it if needed */
        }


        .message-bubble span.timestamp { /* More specific selector for timestamp */
            display: block;
            font-size: 10px; /* Even smaller timestamp */
            color: rgba(255, 255, 255, 0.7); /* Lighter for sent */
            margin-top: 8px; /* More space from content */
            text-align: right;
        }
        .message-bubble.received span.timestamp {
            color: #888; /* Lighter gray for received timestamp */
            text-align: left;
        }
        /* Add a class to the timestamp span in renderMessage JS if not already there */

        .chat-message-options {
            position: absolute;
            top: 5px;
            right: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.2);
        }
        .message-bubble.received .chat-message-options {
            left: 5px;
            right: auto;
            color: var(--gray-color);
            background-color: rgba(0,0,0,0.05);
        }

        .chat-message-options-dropdown {
            position: absolute;
            top: 25px;
            right: 0;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            min-width: 100px;
            display: none;
        }
        .message-bubble.received .chat-message-options-dropdown {
            left: 0;
            right: auto;
        }

        .chat-message-options-dropdown button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 13px;
            color: var(--dark-color);
        }
        .chat-message-options-dropdown button:hover {
            background-color: #f0f0f0;
        }
        .chat-message-options-dropdown button.delete-btn {
            color: var(--danger-color);
        }


        .chat-input {
            padding: 15px;
            border-top: 1px solid #eee;
            display: flex;
            align-items: center;
            background-color: var(--light-color);
        }

        .chat-input input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            margin-right: 10px;
        }

        /* Chat Input Area Modernization */
        .chat-input {
            padding: 10px 15px; /* Slightly reduced padding */
            border-top: 1px solid #e0e0e0; /* Lighter border */
            display: flex;
            align-items: center;
            background-color: #f8f9fa; /* Light background for input area */
            gap: 10px; /* Gap between elements */
        }

        .chat-input input[type="text"] { /* More specific selector */
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px; /* Keep rounded for chat input */
            outline: none;
            /* margin-right: 10px; /* Replaced by gap */
            font-size: 15px;
        }
        .chat-input input[type="text"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.2);
        }


        .chat-action-btn { /* For image upload, voice note etc. */
            background: transparent;
            border: 1px solid var(--primary-color); /* Outline */
            font-size: 20px; /* Slightly smaller icon to fit border */
            color: var(--primary-color);
            cursor: pointer;
            width: 44px; /* Fixed size */
            height: 44px; /* Fixed size */
            border-radius: 50%;
            transition: background-color 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Remove padding to rely on fixed size */
        }
        .chat-action-btn:hover {
            background-color: rgba(var(--primary-color-rgb), 0.1);
        }
        .chat-action-btn.recording { /* Example for a recording state */
            color: var(--danger-color);
        }

        #chatSendButton { /* Specific styling for send button */
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 20px; /* Match input field's roundness */
            padding: 10px 18px; /* Good padding */
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: background-color 0.2s;
        }
        #chatSendButton:hover {
            background-color: #0056b3; /* Darker primary on hover */
        }
        #chatSendButton:disabled { /* Style for disabled send button */
            background-color: var(--gray-color);
            cursor: not-allowed;
        }


        #chatMediaPreviewContainer {
            color: var(--danger-color);
        }
        #chatMediaPreviewContainer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 15px;
        }
        #chatMediaPreviewContainer audio {
            width: calc(100% - 40px);
        }
        #chatMediaPreviewContainer img {
            max-width: 80px;
            max-height: 80px;
            object-fit: contain;
            border-radius: 5px;
        }


        /* Profile Modernization */
        .profile-header {
            background-color: #ffffff; /* Keep it white and clean */
            border-radius: 12px; /* Slightly softer radius */
            margin-bottom: 25px; /* More spacing */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06); /* Softer shadow */
            padding: 25px; /* Increased padding */
            border-top: 4px solid var(--primary-color); /* Accent color border */
        }

        .profile-info {
            display: flex;
            align-items: center; /* Align items vertically for better look */
            flex-wrap: wrap; /* Keep wrap for responsiveness */
        }

        .profile-avatar {
            width: 100px; /* Slightly reduced for a sleeker look */
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid var(--light-color); /* Lighter border, or primary for accent */
            /* margin-top: -60px; /* Removed, as header has padding now */
            margin-right: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .profile-details {
            flex: 1;
            min-width: 0; /* Prevent overflow issues */
        }

        .profile-name {
            font-size: 26px; /* Larger name */
            font-weight: 700; /* Bolder */
            margin-bottom: 8px; /* More space */
            display: flex;
            align-items: center;
            color: var(--dark-color);
        }
        .profile-name .verified-badge { /* Ensure badge aligns well */
            font-size: 20px;
            margin-left: 8px;
        }

        .profile-title { /* User's job title or tagline */
            color: var(--secondary-color); /* Use accent color */
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 12px;
        }

        .profile-bio {
            margin-bottom: 20px; /* More space */
            line-height: 1.6;
            font-size: 14px;
            color: #555; /* Slightly lighter than main text */
        }

        .profile-stats {
            display: flex;
            gap: 25px; /* Increased gap */
            margin-bottom: 25px;
            flex-wrap: wrap;
            padding-top: 15px;
            border-top: 1px solid #eee; /* Separator */
        }

        .profile-stat {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center stat items */
            text-align: center;
        }

        .stat-number {
            font-weight: 600;
            font-size: 20px; /* Larger stat numbers */
            color: var(--primary-color); /* Accent color for numbers */
            cursor: pointer;
        }

        .stat-label {
            font-size: 13px; /* Slightly larger label */
            color: var(--gray-color);
            margin-top: 4px; /* Space between number and label */
            cursor: pointer;
        }

        .profile-actions {
            display: flex;
            gap: 12px; /* Slightly more gap */
            flex-wrap: wrap;
            margin-top: 10px; /* Add some space above actions if stats are present */
        }

        .profile-btn { /* General styling for all profile buttons */
            padding: 10px 18px; /* Increased padding */
            border-radius: 8px; /* Softer radius */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent; /* Base for consistent sizing */
            font-size: 14px;
            text-align: center;
        }

        /* Specific styles for primary and secondary buttons */
        .profile-btn.primary-btn {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        .profile-btn.primary-btn:hover {
            background-color: #0056b3; /* Darker shade or from var */
            border-color: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(var(--primary-color-rgb), 0.2);
        }

        .profile-btn.secondary-btn {
            background-color: transparent;
            color: var(--dark-color); /* Darker text for better contrast */
            border: 1px solid #ccc; /* Clearer border */
        }
        .profile-btn.secondary-btn:hover {
            background-color: #f8f9fa; /* Subtle hover background */
            border-color: #bbb;
            color: var(--primary-color);
            transform: translateY(-1px);
        }
        .profile-btn.secondary-btn i { /* Icon color for secondary buttons */
            margin-right: 6px;
        }


        .profile-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0; /* Slightly darker border */
            margin-bottom: 25px; /* More space below tabs */
            overflow-x: auto;
            white-space: nowrap;
        }

        .profile-tab {
            flex-shrink: 0;
            padding: 12px 20px; /* Increased padding */
            cursor: pointer;
            font-weight: 600;
            color: var(--gray-color);
            border-bottom: 3px solid transparent; /* Thicker indicator line */
            transition: all 0.2s ease-in-out;
            margin-right: 10px; /* Space between tabs */
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .profile-tab:hover {
            color: var(--dark-color);
            background-color: rgba(var(--primary-color-rgb), 0.05);
        }

        .profile-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        .profile-tab i { /* For icons in tabs */
            font-size: 16px;
        }


        .profile-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .profile-grid-item {
            position: relative;
            width: 100%;
            padding-top: 100%;
            background-color: #1A1A1A;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
        }
        .profile-grid-item video, .profile-grid-item img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* User List Page (Followers/Following) */
        .user-list-page {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 20px;
            margin-bottom: 20px;
        }
        .user-list-page h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-align: center;
        }
        .user-list-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .user-list-item:last-child {
            border-bottom: none;
        }
        .user-list-item:hover {
            background-color: #f8f9fa;
        }
        .user-list-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }
        .user-list-info {
            flex-grow: 1;
        }
        .user-list-info h4 {
            font-size: 16px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        .user-list-info p {
            font-size: 13px;
            color: var(--gray-color);
        }


        /* Bottom Navigation - Mobile */
        .bottom-nav {
            position: fixed; /* Changed from sticky to fixed */
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 0;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            height: 60px;
            box-sizing: border-box;
            /* transition: none; /* Explicitly no transition */
        }

        .nav-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--gray-color);
            text-decoration: none;
            font-size: 12px;
        }

        .nav-icon i {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .nav-icon.active {
            color: var(--primary-color);
        }

        .plus-button {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-top: -25px;
            box-shadow: 0 5px 15px rgba(58, 134, 255, 0.3);
        }

        /* Create Post Modal - Full Screen */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 0;
            width: 100%;
            max-width: 100%;
            max-height: 100%;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Comments Modal Specific Styling */
        #commentModal .modal-content {
            width: 100%;
            max-width: 600px;
            height: 80vh;
            position: absolute;
            bottom: 0;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
        }

        /* Settings Modal Specific Styling */
        #settingsModal .modal-content { /* This is for the main settings page (not a modal anymore) */
            width: 100%; /* Take full width of its .feed container */
            max-width: none;
            height: auto;
            min-height: auto;
            border-radius: 0;
            padding: 0; /* Padding will be on .message-section */
            text-align: left;
            box-shadow: none;
            background-color: transparent; /* Let .feed or body background show */
        }
         /* New Settings Buttons CSS */
        .settings-btn {
            display: flex;
            align-items: center;
            width: 100%;
            text-align: left;
            padding: 15px; /* Increased padding */
            margin-bottom: 10px;
            background-color: white; /* White background for buttons */
            border: 1px solid #eee; /* Subtle border */
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s;
            font-size: 16px;
            font-weight: 500;
            color: var(--dark-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .settings-btn i {
            margin-right: 15px; /* Increased margin */
            color: var(--primary-color);
            width: 20px;
            text-align: center;
            font-size: 18px; /* Slightly larger icon */
        }
        .settings-btn:hover {
            background-color: #f8f9fa;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .settings-btn.danger {
            color: var(--danger-color);
        }
        .settings-btn.danger i {
            color: var(--danger-color);
        }
        .settings-btn.danger:hover {
            background-color: rgba(220, 53, 69, 0.05); /* Lighter red hover */
        }


        /* Account Settings Modal Specific Styling - Full Screen */
        #accountSettingsModal .modal-content {
            width: 100%; /* Full width */
            max-width: 100%; /* Full width */
            height: 100%; /* Full height */
            max-height: 100%; /* Full height */
            border-radius: 0; /* No border radius for full screen */
            /* padding: 20px; /* Padding will be applied to modal-body if needed, or kept here */
            text-align: left; /* Align text to left for typical settings page */
            overflow-y: auto; /* Allow scrolling if content exceeds height */
            display: flex; /* Added to make modal-body flex-grow */
            flex-direction: column; /* Stack header and body */
        }
        #accountSettingsModal .modal-header { /* Ensure header is part of the column flow */
            flex-shrink: 0;
        }
        #accountSettingsModal .modal-body { /* Make body scrollable and take remaining space */
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px; /* Add padding here if removed from .modal-content */
        }

        #accountSettingsModal .profile-summary {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        #accountSettingsModal .profile-summary img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }
        #accountSettingsModal .profile-summary div {
            text-align: left;
        }
        #accountSettingsModal .profile-summary h4 {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #accountSettingsModal .profile-summary p {
            font-size: 14px;
            color: var(--gray-color);
        }
        #accountSettingsModal .security-option,
        #accountSettingsModal .setting-item,
        #appSettingsModal .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-size: 15px;
            cursor: pointer;
            background-color: #ffffff;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        #accountSettingsModal .setting-item:hover,
        #appSettingsModal .setting-item:hover {
            background-color: #f8f9fa;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #accountSettingsModal .security-option:last-child,
        #accountSettingsModal .setting-item:last-child {
            border-bottom: none;
        }
        #accountSettingsModal .security-option i,
        #accountSettingsModal .setting-item i {
            margin-left: 10px;
            color: var(--gray-color);
        }
        #accountSettingsModal .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        #accountSettingsModal .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        #accountSettingsModal .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 24px;
        }
        #accountSettingsModal .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        #accountSettingsModal input:checked + .slider {
            background-color: var(--primary-color);
        }
        #accountSettingsModal input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }
        #accountSettingsModal input:checked + .slider:before {
            -webkit-transform: translateX(16px);
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* New Verification Page Styles */
        .verification-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: var(--light-color);
            border-radius: 12px;
        }
        .verification-logo {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .verification-title-group {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .verification-title-group h2 {
            font-size: 24px;
            font-weight: 600;
            color: var(--dark-color);
        }
        .verification-card {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        .verification-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .verification-card p, .verification-card li {
            color: #555;
            line-height: 1.6;
            font-size: 15px;
        }
        .verification-card ul {
            list-style: none;
            padding-left: 0;
        }
        .verification-card ul li {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
        }
        .verification-card ul li i {
            margin-right: 10px;
            color: var(--primary-color);
            margin-top: 4px;
        }
        .verification-status-bar {
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
        }
        .verification-status-bar.pending {
            background-color: rgba(var(--warning-color-rgb, 253, 126, 20), 0.15);
            color: #b05a0d;
            border: 1px solid #fdb473;
        }
        .verification-status-bar.approved {
            background-color: rgba(var(--success-color-rgb, 40, 167, 69), 0.15);
            color: #1a682b;
            border: 1px solid #a3d9b1;
        }
        .verification-status-bar.rejected {
            background-color: rgba(var(--danger-color-rgb, 220, 53, 69), 0.15);
            color: #7a1c25;
            border: 1px solid #f5c6cb;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .modal-title {
            font-weight: 600;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--gray-color);
        }

        .modal-body {
            padding: 15px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .post-form {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        .post-form textarea {
            width: 100%;
            border: none;
            outline: none;
            resize: none;
            min-height: 100px;
            font-size: 16px;
            margin-bottom: 15px;
            flex-grow: 1;
        }

        .post-options-bar {
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #eee;
            border-bottom: 1px solid #eee;
            padding: 10px 0;
            margin-bottom: 15px;
        }

        .add-to-post {
            display: flex;
            gap: 15px;
        }

        .add-option {
            display: flex;
            align-items: center;
            color: var(--gray-color);
            cursor: pointer;
        }

        .add-option i {
            margin-right: 5px;
        }

        .post-submit-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 15px;
            font-weight: 600;
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .post-submit-btn.active {
            opacity: 1;
        }

        .preview-container {
            margin-bottom: 15px;
            position: relative;
        }

        .preview-image {
            width: 100%;
            border-radius: 8px;
            max-height: 300px;
            object-fit: contain;
            background-color: #f5f5f5;
        }

        .preview-video {
            width: 100%;
            border-radius: 8px;
            max-height: 300px;
            background-color: #1A1A1A;
        }

        .remove-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Explore Page */
        .explore-tabs {
            display: flex;
            border-bottom: 1px solid #eee;
            margin-bottom: 20px;
        }

        .explore-tab {
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
            color: var(--gray-color);
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .explore-tab i {
            margin-right: 0;
            font-size: 18px;
        }


        .explore-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .stories-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 10px; /* Keep some padding for visual separation if needed */
            /* Added new story styles below, this might be overridden or complemented */
            scroll-snap-type: x mandatory;
            scrollbar-width: none; /* Firefox */
        }
        .stories-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari */
        }


        .story-item { /* This is the old .story-item, will be replaced by .story */
            /* Styles from .story-item will be merged or replaced by .story specific styles */
            min-width: auto; /* Reset from old value */
            text-align: center;
            cursor: pointer;
            /* New styles from .story will take precedence */
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            scroll-snap-align: start;
        }

        .story-item.add-story { /* Keep add-story specific styling */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--gray-color);
            border-radius: 10px; /* Keep or adjust if new .story has different radius */
            padding: 10px;
            min-height: 120px; /* Or adjust to match new story height + padding */
            color: var(--gray-color);
            font-weight: 600;
            font-size: 14px;
            width: 80px; /* Match new story image width */
            height: auto; /* Let content define height */
            margin-right: 12px; /* Match gap */
        }
        .story-item.add-story img { /* If add story uses an img, it won't exist */
             /* No specific img style for add-story button from new CSS */
        }
        .story-item.add-story i {
            font-size: 30px;
            margin-bottom: 5px;
        }
        .story-item.add-story span {
            /* font-size: 12px; /* from new .story span */
            /* color: #333; /* from new .story span */
            /* margin-top: 5px; /* from new .story span */
        }


        .story-avatar { /* This selector might become story-item > img or .story > img */
            /* width: 70px; /* Old size */
            /* height: 70px; /* Old size */
            width: 80px; /* New size from .story img */
            height: 80px; /* New size from .story img */
            object-fit: cover;
            border-radius: 50%;
            /* border: 2px solid var(--primary-color); /* Old border */
            border: 3px solid #f23645; /* New border from .story img */
            padding: 2px;
            background: white; /* New from .story img */
            margin-bottom: 5px; /* Old spacing, new is margin-top on span */
        }
        .story-avatar.viewed { /* Keep this modifier */
            border-color: var(--gray-color); /* Or use a less prominent color than #f23645 */
        }
        .story-avatar.my-story-avatar { /* Keep this modifier */
            border-color: var(--success-color); /* Or a different brand color for "my story" */
            border-width: 3px;
        }


        .story-username { /* This selector might become story-item > span or .story > span */
            /* font-size: 12px; /* Old size, matches new */
            /* white-space: nowrap; /* Old, useful */
            /* overflow: hidden; /* Old, useful */
            /* text-overflow: ellipsis; /* Old, useful */
            /* max-width: 100px; /* Old, might need adjustment based on 80px image */
            margin-top: 5px; /* New from .story span */
            font-size: 12px; /* New from .story span */
            color: #333; /* New from .story span */
            max-width: 80px; /* To match image width */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Renaming .stories-container to .story-container for direct application of new styles */
        /* All .story-item will become .story for direct application of new styles */
        /* The JS function renderStoryItem will need to use class 'story' instead of 'story-item' */
        /* and its child img will get .story-avatar styles, and child p will get .story-username styles */

        /* New Story CSS from user - to be integrated */
        .story-container { /* This will be the new .stories-container */
          display: flex;
          overflow-x: auto;
          gap: 12px;
          padding: 10px;
          scroll-snap-type: x mandatory;
          scrollbar-width: none; /* Firefox */
        }
        .story-container::-webkit-scrollbar {
          display: none; /* Chrome, Safari */
        }

        .story { /* This will be the new .story-item */
          flex: 0 0 auto;
          display: flex;
          flex-direction: column;
          align-items: center;
          scroll-snap-align: start;
          cursor: pointer; /* Added from old .story-item */
          text-align: center; /* Added from old .story-item */
        }

        .story img { /* This will be the new .story-avatar */
          width: 80px;
          height: 80px;
          object-fit: cover;
          border-radius: 50%;
          border: 3px solid #f23645; /* or your brand color */
          padding: 2px;
          background: white;
        }

        .story span { /* This will be the new .story-username */
          margin-top: 5px;
          font-size: 12px;
          color: #333;
          max-width: 80px; /* Added for consistency */
          white-space: nowrap; /* Added from old .story-username */
          overflow: hidden; /* Added from old .story-username */
          text-overflow: ellipsis; /* Added from old .story-username */
        }
        /* End of new story CSS integration */


        /* Story Preview Modal */
        .story-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 1001;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .story-modal-content {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .story-media {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .story-user-info {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 8px 12px;
            border-radius: 20px;
        }

        .story-user-info img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .story-user-info span {
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .story-actions-bottom {
            position: absolute;
            bottom: 20px;
            width: 90%;
            max-width: 400px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .story-actions-bottom input {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            outline: none;
        }

        .story-actions-bottom input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .story-actions-bottom button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        .story-actions-bottom button.liked {
            color: var(--danger-color);
        }

        .close-story-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .story-nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 40px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            z-index: 1002;
            padding: 10px;
            transition: color 0.3s;
        }
        .story-nav-arrow:hover {
            color: white;
        }
        #prevStoryBtn {
            left: 10px;
        }
        #nextStoryBtn {
            right: 10px;
        }


        .verified-badge {
            color: var(--secondary-color); /* Purple color for the badge */
            font-size: 1em; /* Use em for sizing relative to parent font size */
            margin-left: 5px;
        }


        /* Tags and Location input styling */
        .tag-input-container, .location-input-container {
            margin-bottom: 15px;
        }

        .tag-input-container input, .location-input-container input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .tags-display {
            margin-top: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .tag-item {
            background-color: var(--primary-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            display: flex;
            align-items: center;
        }

        .tag-item .remove-tag {
            margin-left: 5px;
            cursor: pointer;
            font-size: 10px;
        }

        .visibility-options {
            margin-bottom: 15px;
        }

        .visibility-options label {
            margin-right: 15px;
            font-size: 14px;
            color: var(--gray-color);
        }

        .visibility-options select {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
        }

        /* Explore Reels Grid */
        .explore-reels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding-bottom: 10px;
        }
        .explore-reel-item {
            width: 100%;
            height: 250px;
            background-color: #1A1A1A;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        .explore-reel-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .explore-reel-item .reel-user-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
        }
        .explore-reel-item .reel-user-info img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 5px;
            border: 1px solid white;
        }
        @media (min-width: 600px) {
            .explore-reels-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }
        }
        @media (min-width: 992px) {
            .explore-reels-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        /* Edit Profile Modal */
        #editProfileModal .modal-content {
            width: 90%;
            max-width: 500px;
            height: auto;
            min-height: 300px;
            border-radius: 10px;
            position: relative;
        }

        #editProfileModal .edit-profile-step {
            display: none;
            padding: 20px;
            text-align: center;
        }
        #editProfileModal .edit-profile-step.active {
            display: block;
        }
        #editProfileModal .edit-profile-step h3 {
            margin-bottom: 20px;
            color: var(--primary-color);
        }
        #editProfileModal .edit-profile-step input[type="text"],
        #editProfileModal .edit-profile-step textarea {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            resize: vertical;
            min-height: 80px;
        }
        #editProfileModal .edit-profile-step .profile-pic-preview {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
            margin: 0 auto 20px;
            border: 3px solid var(--primary-color);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #editProfileModal .edit-profile-step .btn-group {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin-top: 20px;
        }
        #editProfileModal .edit-profile-step .btn-group button {
            flex: 1;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        /* Share Modal */
        #shareModal .modal-content {
            width: 100%;
            max-width: 100%;
            height: 50vh; /* Half screen height */
            position: absolute;
            bottom: 0;
            left: 0;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            animation: slideUp 0.3s ease-out;
            padding: 20px;
            text-align: center;
        }
        #shareModal .share-options button {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            background-color: white;
            color: var(--primary-color);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        #shareModal .share-options button:hover {
            background-color: var(--primary-color);
            color: white;
        }
        #shareModal .share-options button i {
            margin-right: 10px;
        }

        /* Notification Toast Styles */
        .notification-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
        }
        .notification-toast.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -10px);
        }
        .notification-toast.success { background-color: var(--success-color); }
        .notification-toast.error { background-color: var(--danger-color); }
        .notification-toast.info { background-color: var(--primary-color); }


        /* General Loading Spinner */
        .loading-spinner-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            width: 100%;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); /* Lighter border for light backgrounds */
            border-left-color: var(--primary-color); /* Use primary color for active part */
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite; /* Reuse existing spin animation */
        }
        /* @keyframes spin is already globally defined */

        /* New Grid/Dot Loader */
        .loader {
          width: 50px; /* Or adjust as needed */
          aspect-ratio: 1;
          display: grid;
          margin: auto; /* For centering if its container is not flex centering it */
        }
        .loader::before,
        .loader::after {
          content:"";
          grid-area: 1/1;
          /* --c:no-repeat radial-gradient(farthest-side,#25b09b 92%,#0000); /* Original color */
          --c:no-repeat radial-gradient(farthest-side,#000000 92%,#0000); /* Changed to black */
          background:
            var(--c) 50%  0,
            var(--c) 50%  100%,
            var(--c) 100% 50%,
            var(--c) 0    50%;
          background-size: 12px 12px;
          animation: l12 1s infinite;
        }
        .loader::before {
          margin: 4px;
          filter: hue-rotate(45deg); /* This will make the black dots appear slightly different due to filter, or remove if pure black is needed */
          background-size: 8px 8px;
          animation-timing-function: linear;
        }

        @keyframes l12 {
          100%{transform: rotate(.5turn)}
        }
        /* End New Grid/Dot Loader */


        /* Confirmation Modal Styles */
        .confirm-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }
        .confirm-modal-content {
            background-color: #fefefe;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 400px;
            border-radius: 10px;
            text-align: center;
        }
        .confirm-modal-content p {
            margin-bottom: 20px;
            font-size: 16px;
        }
        .confirm-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .confirm-modal-buttons button {
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }
        #confirmBtnYes {
            background-color: var(--danger-color);
            color: white;
        }
        #confirmBtnNo {
            background-color: #ccc;
        }

        /* Search Page Specific Styles */
        .search-page-container { /* General Search Page */
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        .search-input-wrapper {
            position: relative;
            margin-bottom: 20px;
        }
        .search-input-wrapper input {
            width: 100%;
            padding: 12px 15px 12px 45px;
            border: 1px solid #ddd;
            border-radius: 30px;
            font-size: 16px;
            outline: none;
            transition: all 0.3s;
        }
        .search-input-wrapper input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(58, 134, 255, 0.2);
        }
        .search-input-wrapper i.fa-search { /* Specific to search icon in wrapper */
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray-color);
        }
        .search-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .search-filter-btn {
            padding: 8px 15px;
            border: 1px solid var(--primary-color);
            border-radius: 20px;
            background-color: white;
            color: var(--primary-color);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .search-filter-btn.active, .search-filter-btn:hover {
            background-color: var(--primary-color);
            color: white;
        }
        .search-results-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .search-result-user-card {
            display: flex;
            align-items: center;
            background-color: var(--light-color);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-result-user-card:hover {
            background-color: #e9ecef;
        }
        .search-result-user-info h4 {
            font-size: 16px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        .search-result-user-info p {
            font-size: 13px;
            color: var(--gray-color);
        }
        /* Reels Search Page Specific Styles */
        #reelsSearchPage {
            background-color: white; /* Full page background */
            height: 100vh; /* Full viewport height */
            display: flex;
            flex-direction: column;
        }
        #reelsSearchPage .reels-search-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            background-color: var(--light-color);
        }
        #reelsSearchPage .reels-search-header .back-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--gray-color);
            cursor: pointer;
            margin-right: 15px;
        }
        #reelsSearchPage .reels-search-header h3 {
            flex-grow: 1;
            text-align: center;
            margin: 0;
            font-size: 18px;
        }
        #reelsSearchPage .search-input-wrapper { /* Reuse existing style */
            padding: 15px;
        }
        #reelsSearchResultsContainer.explore-reels-grid { /* Reuse grid style */
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }


        /* Support Icon on Post */
        .support-icon {
            margin-left: 10px;
            color: var(--success-color);
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .support-icon:hover {
            transform: scale(1.1);
        }

        /* Support Creator Modal */
        #supportCreatorModal .modal-content,
        #paymentModal .modal-content {
            width: 90%;
            max-width: 400px;
            height: auto;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        .support-price-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .support-price-btn {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .support-price-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Comment Specific Styles */
        .comment-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .comment-item img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }
        .comment-content-wrapper {
            flex-grow: 1;
            background-color: #f0f2f5;
            padding: 10px 12px;
            border-radius: 18px;
        }
        .comment-content-wrapper strong {
            font-size: 14px;
            margin-right: 5px;
            display: flex;
            align-items: center;
        }
        .comment-content-wrapper p {
            font-size: 14px;
            line-height: 1.4;
            margin-top: 2px;
        }
        .comment-actions {
            display: flex;
            gap: 15px;
            margin-top: 5px;
            margin-left: 55px;
            font-size: 12px;
            color: var(--gray-color);
        }
        .comment-action-btn {
            background: none;
            border: none;
            color: inherit;
            font-size: 12px;
            cursor: pointer;
            font-weight: 600;
            padding: 0;
            transition: color 0.2s;
        }
        .comment-action-btn:hover {
            color: var(--primary-color);
        }
        .comment-action-btn.liked {
            color: var(--primary-color);
        }
        .comment-time {
            font-size: 11px;
            color: var(--gray-color);
            margin-right: 15px;
        }

        /* Load More Button */
        .load-more-btn {
            display: block;
            width: fit-content;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.3s;
        }
        .load-more-btn:hover {
            opacity: 0.9;
        }
        .load-more-btn:disabled {
            background-color: var(--gray-color);
            cursor: not-allowed;
        }

        /* Mentions Dropdown Styles */
        .mentions-dropdown {
            position: absolute; /* Positioned by JS near the input */
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 150px;
            overflow-y: auto;
            z-index: 1100; /* Above most elements, but below modals if active */
            width: auto; /* Adjust width based on content or set a fixed one */
            min-width: 150px;
        }
        .mentions-dropdown .mention-item {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .mentions-dropdown .mention-item:hover {
            background-color: #f0f0f0;
        }
        .mentions-dropdown .mention-item img { /* Small avatar in dropdown */
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 8px;
            object-fit: cover;
        }
        .mentions-dropdown .mention-item .username {
            font-weight: 500;
        }
        .mentions-dropdown .mention-item .name {
            font-size: 12px;
            color: var(--gray-color);
            margin-left: 5px;
        }
        /* End Mentions Dropdown Styles */

        /* Suggested Users on Home Feed */
        .suggested-users-container {
            background-color: #f9f9f9; /* Slightly different background */
            padding: 15px;
            margin-bottom: 25px; /* Same as post-card margin */
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .suggested-users-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .suggested-users-header h4 {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark-color);
        }
        .suggested-users-header .see-all-btn { /* Optional See All button */
            font-size: 13px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        .suggested-users-scroll {
            display: flex;
            overflow-x: auto;
            gap: 15px;
            padding-bottom: 10px; /* For scrollbar visibility if needed */
        }
        /* Hide scrollbar visually if desired, while keeping functionality */
        .suggested-users-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .suggested-users-scroll::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }
        .suggested-users-scroll::-webkit-scrollbar-thumb:hover {
            background: #bbb;
        }

        .suggested-user-card {
            min-width: 150px; /* Ensure cards have a minimum width */
            max-width: 160px;
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 1px 4px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .suggested-user-card .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
        }
        .suggested-user-card .username {
            font-size: 14px;
            font-weight: 600;
            color: var(--dark-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        .suggested-user-card .name {
            font-size: 12px;
            color: var(--gray-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        .suggested-user-card .sugg-follow-btn {
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 6px;
            margin-top: 8px;
            width: 100%;
        }
        .suggested-user-card .sugg-remove-btn {
            background: none;
            border: none;
            color: var(--gray-color);
            font-size: 11px;
            margin-top: 5px;
            cursor: pointer;
        }
        .suggested-user-card .sugg-remove-btn:hover {
            text-decoration: underline;
        }
        /* End Suggested Users */

        /* Explore Page New Styles */
        .explore-new-tabs { /* Container for the new tab buttons */
            display: flex;
            justify-content: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }
        .explore-tab-btn {
            padding: 8px 20px;
            font-size: 16px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--gray-color);
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: color 0.3s, border-color 0.3s, font-weight 0.3s;
        }
        .explore-tab-btn.active {
            color: var(--primary-color);
            font-weight: 600;
            border-bottom-color: var(--primary-color);
        }
        .explore-tab-btn:hover:not(.active) {
            color: var(--dark-color);
        }

        #popularReelsSection h3, #popularPostsSection h3, #exploreHashtagsViewContent h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            padding-left: 15px; /* Default padding for desktop */
        }

        #popularReelsSection {
            margin-bottom: 25px;
        }
        #exploreHashtagsViewContent h3 {
             padding-left: 0;
        }

        /* Responsive adjustments for Explore Page sections */
        @media (max-width: 767px) {
            #popularPostsSection, #exploreHashtagsViewContent {
                padding-left: 15px;
                padding-right: 15px;
            }
            #popularReelsSection h3, #popularPostsSection h3, #exploreHashtagsViewContent h3 {
                padding-left: 0; /* No extra padding on title inside padded container */
            }
            .posts-grid-container {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Adjust for smaller screens */
            }
        }

        /* Styling for the "Popular Reels" section container to give it a card look */
        #popularReelsSection {
            background-color: var(--light-color); /* Or #f0f2f5 or similar subtle card bg */
            padding: 15px; /* Padding for the entire section card */
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin: 0 15px 25px 15px; /* Add horizontal margin to inset the card */
        }
        /* Adjust title padding if section now has its own padding */
        #popularReelsSection h3 {
            padding-left: 0;
            margin-left: 0; /* Ensure title aligns with the section's padding */
        }


        .horizontal-scroll-container { /* This is div#popularReelsContainer */
            display: flex;
            overflow-x: auto;
            /* padding: 0 15px 15px 15px; /* Padding was here, now on #popularReelsSection or adjusted */
            padding-bottom: 10px; /* From demo, for space below cards if needed */
            gap: 14px; /* Adjusted from 15px to 14px per demo */
            scrollbar-width: none; /* For Firefox - hide scrollbar */
            overscroll-behavior-x: contain; /* Prevent scroll chaining to parent */
            touch-action: pan-x; /* Prioritize horizontal panning within this element for touch */
            scroll-snap-type: x mandatory; /* Enable snap scrolling */
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none; /* For Chrome, Safari, Edge - hide scrollbar */
        }

        .horizontal-scroll-container.active-swipe { /* Optional: For styling during mouse drag */
            cursor: grabbing;
        }

        .explore-reel-item.horizontal-reel-card { /* Styles for compact reel cards in horizontal list */
            min-width: 160px;
            width: 160px;
            height: 240px;
            position: relative;
            border-radius: 16px; /* Per demo */
            overflow: hidden;
            background-color: #000; /* Per demo */
            flex-shrink: 0;
            cursor: pointer;
            scroll-snap-align: start;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Per demo */
            display: flex; /* Per demo, for centering content if needed */
            align-items: center; /* Per demo */
            justify-content: center; /* Per demo */
        }
        .horizontal-reel-card video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .horizontal-reel-card .reel-user-info {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 12px;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
        }
        .horizontal-reel-card .reel-user-info img {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 5px;
            border: 1px solid rgba(255,255,255,0.5);
        }
        .horizontal-reel-card .reel-view-count {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 11px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 3px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        .horizontal-reel-card .reel-view-count i {
            margin-right: 4px;
        }

        .posts-grid-container { /* For Explore Hashtags (keeps grid) and was for Popular Posts */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* Responsive columns */
            gap: 20px; /* Gap between post cards */
            padding: 0 15px 15px 15px; /* Padding for the grid container */
        }
        .posts-grid-container .post-card { /* Specific to cards within the grid */
            margin-bottom: 0;
        }

        /* Styles for #popularPostsContainer to be a single-column feed like home */
        #popularPostsContainer {
            /* display: block; */ /* Default for div, no need to set explicitly */
            /* No grid properties */
            padding: 0 15px 15px 15px; /* Keep padding if desired for the section */
        }
        #popularPostsContainer .post-card {
            margin-bottom: 25px; /* Restore default post-card bottom margin */
             /* Ensure post-cards take full width if they were constrained by grid */
            width: 100%;
            max-width: 100%; /* Override any max-width from grid item context if necessary */
        }


        .explore-header-controls { /* This class might be unused now or needs re-evaluation */
            display: flex;
            justify-content: center; /* Center the button */
            padding: 10px 15px;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        #exploreFilterButton { /* Specific styling if needed, otherwise relies on .profile-btn */
            padding: 8px 15px;
            font-size: 14px;
        }

        /* Default Reels Grid on Explore Page (can reuse .explore-reels-grid) */
        #exploreContent.explore-reels-grid-default {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Same as .explore-reels-grid */
            gap: 15px; /* Same as .explore-reels-grid */
            padding: 0 15px 15px 15px; /* Add some padding around the grid */
        }
        /* Individual items within this grid will use .explore-reel-item styles */

        /* Mixed Feed on Explore Page */
        #exploreContent.explore-mixed-feed {
            padding: 0 15px 15px 15px; /* Padding for the feed */
            /* This class is mainly for JS to target. Posts will use .post-card styling. */
            /* If a different layout for mixed items is desired, add styles here. */
            /* For example, if you wanted a masonry layout, it would involve more complex CSS. */
        }
        #exploreContent.explore-mixed-feed .post-card {
            /* Override post-card margin if needed for a tighter grid in mixed feed */
            /* margin-bottom: 15px; */
        }


        /* New Group Modal Styles */
        #newGroupModal .user-list-item { /* Style for user items in the group modal */
            padding: 8px 10px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #newGroupModal .user-list-item:hover {
            background-color: #f8f9fa;
        }
        #newGroupModal .user-list-item:last-child {
            border-bottom: none;
        }
        #newGroupModal .user-list-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 12px;
        }
        #newGroupModal .user-list-item .user-list-info {
            flex-grow: 1;
        }
        #newGroupModal .user-list-item .user-list-info h4 {
            font-size: 15px;
            margin-bottom: 3px;
        }
        #newGroupModal .user-list-item .user-list-info p {
            font-size: 12px;
            color: var(--gray-color);
        }
        #newGroupModal .user-list-item input[type="checkbox"] {
            transform: scale(1.2);
            margin-left: 10px;
            cursor: pointer;
        }
        #newGroupIconPreview {
            display: block; /* Ensure it's block for margin auto to work */
            margin: 10px auto; /* Center the preview */
            border: 2px dashed var(--gray-color);
            padding: 5px;
        }


        /* Responsive */
        @media (min-width: 992px) {
            .sidebar {
                display: block;
            }

            .main-content {
                margin-left: 250px;
            }

            .bottom-nav {
                display: none;
            }

            body {
                padding-bottom: 0; /* No bottom nav on desktop, so no body padding needed */
            }
        }

        @media (max-width: 991px) { /* Styles for tablet and mobile where bottom-nav is potentially visible */
            body {
                padding-bottom: 60px; /* Add padding to body for bottom nav */
            }
        }


        @media (max-width: 768px) {
            .search-bar {
                display: none;
            }
            .search-icon-mobile {
                display: block;
            }

            .content-area {
                flex-direction: column;
            }

            .sidebar-right {
                display: none;
            }

            #commentModal .modal-content {
                height: 70vh;
            }

            .profile-info {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            .profile-avatar {
                margin-top: -60px;
                margin-bottom: 20px;
                margin-right: 0;
            }
            .profile-details {
                width: 100%;
            }
            .profile-stats, .profile-actions {
                justify-content: center;
            }
            .profile-tabs {
                justify-content: flex-start;
            }

            .main-content {
                padding-top: 70px; /* Header height (60px) + 10px breathing room */
                padding-left: 0; /* Edge-to-edge feed content on mobile */
                padding-right: 0;
                padding-bottom: 20px; /* Keep bottom padding */
            }
            .post-card, .skeleton-post-card {
                margin-left: 0;
                margin-right: 0;
                border-radius: 0; /* Edge-to-edge posts on mobile */
                border-left: none; /* No side borders for edge-to-edge */
                border-right: none;
                /* box-shadow: none; /* Optional: flatter look for mobile */
            }
            /* Keep top/bottom border for separation between posts */
            .post-card:first-child {
                border-top: 1px solid #f0f0f0; /* Add top border for first card if others have it from bottom */
            }
             .post-card:not(:first-child) {
                /* The margin-bottom handles separation, border-top on .post-stats/actions provides internal line */
            }

            .post-header, .post-content, .post-stats, .post-actions {
                padding-left: 15px; /* Keep internal horizontal padding */
                padding-right: 15px;
            }
             .skeleton-post-card { /* Ensure skeleton also respects edge-to-edge */
                padding: 15px;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }
            .post-content {
                padding-bottom: 15px; /* Space below text if media follows */
                /* padding-left and padding-right are handled by the general rule for .post-content */
            }
            .post-card .post-image,
            .post-card .post-video-container,
            .post-card .post-gallery-container {
                margin-left: -15px; /* Counteract .post-content padding */
                margin-right: -15px; /* Counteract .post-content padding */
                width: calc(100% + 30px); /* Span full width */
                border-radius: 0; /* Edge-to-edge look */
            }
            .post-card .post-image {
                /* Specific if different from video/gallery, e.g. if it had its own margin-bottom */
                 margin-bottom: 15px; /* Keep its original margin-bottom if content follows it */
            }
             .post-card .post-video-container, .post-card .post-gallery-container {
                 margin-bottom: 15px; /* Keep original margin-bottom */
             }


            .post-card .tags-display {
                padding-left: 15px;
                padding-right: 15px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <!-- Authentication Pages -->
    <div id="auth-container" style="display: none;">
      <div class="auth-inner-container"> <!-- Renamed class to avoid conflict with ID, new CSS will target this -->
        <div class="logo">
          <img src="https://thumbsnap.com/i/6UjxkZoq.jpg" alt="Swavoti Logo">
        </div>
        <div class="tab-buttons">
          <button id="loginTab" class="active">Login</button>
          <button id="signupTab">Sign Up</button>
        </div>

        <!-- Login Form -->
        <form id="newLoginForm" class="active"> <!-- Changed ID -->
          <div class="auth-error" id="new-login-error" style="display: none; color: red; text-align: center; margin-bottom: 10px;"></div> <!-- Added error div -->
          <input type="email" id="new-login-email" placeholder="Email" required />
          <input type="password" id="new-login-password" placeholder="Password" required />
          <button type="submit" class="submit-btn">Login</button>
          <div class="link">Forgot password? <a href="#">Recover</a></div>
        </form>

        <!-- Signup Form -->
        <form id="newSignupForm"> <!-- Changed ID -->
          <div class="auth-error" id="new-signup-error" style="display: none; color: red; text-align: center; margin-bottom: 10px;"></div> <!-- Added error div -->
          <input type="text" id="new-signup-name" placeholder="Full Name" required />
          <input type="text" id="new-signup-username" placeholder="Username" required />
          <input type="email" id="new-signup-email" placeholder="Email" required />
          <input type="password" id="new-signup-password" placeholder="Password" required />

          <div class="checkbox-container">
            <input type="checkbox" id="termsCheck" />
            <label for="termsCheck">
              I agree to the <a href="#">Swavoti Terms of Service</a> & <a href="#">Privacy Policy</a>
            </label>
          </div>

          <button type="submit" class="submit-btn" id="newSignupBtn" disabled>Create Account</button> <!-- Changed ID -->
          <div class="link">Already have an account? <a href="#" id="switchToLoginLink">Login</a></div> <!-- Added ID for JS hook -->
        </form>
      </div>
      <script>
        // This script should ideally be part of the main script block or loaded externally,
        // but placing it here as per user's provided structure for now.
        // It will be adjusted/merged during the Firebase JS adaptation step.
        const loginTab = document.getElementById("loginTab");
        const signupTab = document.getElementById("signupTab");
        const newLoginForm = document.getElementById("newLoginForm"); // Updated ID
        const newSignupForm = document.getElementById("newSignupForm"); // Updated ID
        const termsCheck = document.getElementById("termsCheck");
        const newSignupBtn = document.getElementById("newSignupBtn"); // Updated ID
        const switchToLoginLink = document.getElementById("switchToLoginLink");

        if (loginTab && signupTab && newLoginForm && newSignupForm) {
            loginTab.onclick = () => {
              loginTab.classList.add("active");
              signupTab.classList.remove("active");
              newLoginForm.classList.add("active");
              newSignupForm.classList.remove("active");
              document.getElementById('new-login-error').style.display = 'none'; // Hide errors on tab switch
              document.getElementById('new-signup-error').style.display = 'none';
            };

            signupTab.onclick = () => {
              signupTab.classList.add("active");
              loginTab.classList.remove("active");
              newSignupForm.classList.add("active");
              newLoginForm.classList.remove("active");
              document.getElementById('new-login-error').style.display = 'none';
              document.getElementById('new-signup-error').style.display = 'none';
            };
        }

        if (switchToLoginLink) {
            switchToLoginLink.onclick = (e) => {
              e.preventDefault();
              if(loginTab) loginTab.click();
            }
        }

        if (termsCheck && newSignupBtn) {
            termsCheck.addEventListener("change", () => {
              newSignupBtn.disabled = !termsCheck.checked;
            });
        }
      </script>
    </div>

    <!-- Main App -->
    <div id="app-container" style="display: none;">
        <div class="container">
            <!-- Sidebar - Desktop -->
            <div class="sidebar">
                <div class="logo">
                    <span>Swavoti</span>
                </div>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="#home" class="nav-link active" data-page="home">
                            <i class="fas fa-home"></i>
                            <span>Home</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#explore" class="nav-link" data-page="explore">
                            <i class="fas fa-compass"></i>
                            <span>Explore</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#reels" class="nav-link" data-page="reels">
                            <i class="fas fa-film"></i>
                            <span>Reels</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#notifications" class="nav-link" data-page="notifications">
                            <i class="fas fa-bell"></i>
                            <span>Notifications</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#messages" class="nav-link" data-page="messages">
                            <i class="fas fa-envelope"></i>
                            <span>Messages</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#profile" class="nav-link" data-page="profile">
                            <i class="fas fa-user"></i>
                            <span>Profile</span>
                        </a>
                    </li>
                </ul>
                <button class="create-post-btn" id="createPostBtn">
                    <i class="fas fa-plus"></i>
                    <span>Create Post</span>
                </button>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Header -->
                <div class="header">
                    <div class="search-bar">
                        <i class="fas fa-search"></i>
                        <input type="text" placeholder="Search Swavoti...">
                    </div>
                    <div class="user-actions">
                        <!-- Mobile Search Icon -->
                        <div class="search-icon-mobile" id="searchIconMobile">
                            <i class="fas fa-search"></i>
                        </div>
                        <div class="notification-icon" id="notificationIcon">
                            <i class="fas fa-bell"></i>
                            <span class="notification-count" id="notificationCount">0</span>
                        </div>
                        <div class="message-icon" id="messageIcon">
                            <i class="fas fa-envelope"></i>
                            <span class="message-count" id="messageCount">0</span>
                        </div>
                        <div class="user-profile" id="user-profile">
                            <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile">
                            <span id="username-display">User</span>
                        </div>
                    </div>
                </div>

                <!-- Content Area -->
                <div class="content-area" id="contentArea">
                    <!-- Home Page -->
                    <div class="feed" id="homePage">
                        <div id="homeFeed">
                            <!-- Posts and reels will be loaded here -->
                        </div>
                    </div>

                    <!-- Explore Page -->
                    <div class="feed" id="explorePage" style="display: none;">
                        <div class="explore-new-tabs" style="display: flex; justify-content: center; padding: 10px 0; border-bottom: 1px solid #eee; margin-bottom: 15px;">
                            <button class="explore-tab-btn active" data-explore-view="forYou" style="padding: 8px 20px; font-size: 16px; background: none; border: none; cursor: pointer; color: var(--primary-color); font-weight: 600; border-bottom: 2px solid var(--primary-color);">For You</button>
                            <button class="explore-tab-btn" data-explore-view="exploreHashtags" style="padding: 8px 20px; font-size: 16px; background: none; border: none; cursor: pointer; color: var(--gray-color); font-weight: 500; border-bottom: 2px solid transparent;">Explore</button>
                        </div>
                        <div id="exploreContent">
                            <!-- Content for "For You" or "Explore Hashtags" will be loaded here -->
                            <!-- Structure for "For You" view -->
                            <div id="forYouViewContent" style="display: none;">
                                <!-- Popular Reels Section Removed -->
                                <div id="popularPostsSection" class="popular-posts-section"> <!-- Removed inline padding -->
                                    <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 15px; padding-top: 15px;">Popular Posts</h3>
                                    <div id="popularPostsContainer">
                                        <!-- Popular Post cards will be loaded here -->
                                    </div>
                                </div>
                            </div>
                            <!-- Structure for "Explore Hashtags" view -->
                            <div id="exploreHashtagsViewContent" style="display: none;"> <!-- Removed inline padding -->
                                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 15px;">Explore Tags</h3>
                                 <div id="exploreHashtagsContainer" class="posts-grid-container">
                                    <!-- Tagged posts will be loaded here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Reels Page (Container for fullscreen reels) -->
                    <div class="feed" id="reelsPage" style="display: none;">
                        <!-- This page is now primarily a trigger for the fullscreen reels view -->
                    </div>


                    <!-- Notifications Page -->
                    <div class="feed" id="notificationsPage" style="display: none;">
                        <div class="search-input-wrapper" style="padding: 15px 15px 0 15px; margin-bottom: 10px;">
                            <i class="fas fa-search"></i>
                            <input type="text" id="notificationSearchInput" placeholder="Search notifications..." style="border-radius: 20px; padding-left: 40px;">
                        </div>
                        <div id="notificationsListContainer" style="padding: 0 15px 15px 15px;">
                            <div id="notificationsList">
                                <!-- Notifications will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Messages Page -->
                    <div class="feed" id="messagesPage" style="display: none;">
                        <!-- Stories section removed from messages page -->
                        <!-- <div id="messagePageStories" class="stories-container" style="padding: 0 15px 15px 15px; margin-bottom: 0;"> -->
                            <!-- Stories will be loaded here by loadStories() -->
                        <!-- </div> -->
                        <div class="messages-header" style="display: flex; justify-content: space-between; align-items: center; padding: 15px;">
                            <div class="search-input-wrapper" style="flex-grow: 1; margin-bottom: 0;">
                                <i class="fas fa-search"></i>
                                <input type="text" id="conversationSearchInput" placeholder="Search conversations..." style="border-radius: 20px; padding-left: 40px;">
                            </div>
                            <button id="messagesSettingsBtn" class="chat-action-btn" style="margin-left: 10px;"><i class="fas fa-cog"></i></button>
                        </div>
                        <div class="message-filters" style="padding: 10px 15px; display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <button class="message-filter-btn active" data-message-filter="inbox">Inbox</button>
                                <button class="message-filter-btn" data-message-filter="groups">Groups</button>
                            </div>
                            <button class="profile-btn primary-btn" id="newGroupBtn" style="padding: 8px 12px; font-size: 14px;">
                                <i class="fas fa-plus" style="margin-right: 5px;"></i> New Group
                            </button>
                        </div>

                        <div class="message-section">
                            <h3 class="message-section-title">Conversations</h3>
                            <div id="conversationsList">
                                <!-- Conversations will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Profile Page -->
                    <div class="feed" id="profilePage" style="display: none;">
                        <div class="profile-header">
                            <div class="profile-info">
                                <img id="profileAvatar" src="https://ui-avatars.com/api/?name=User&background=random" class="profile-avatar" alt="Profile">
                                <div class="profile-details">
                                    <h1 class="profile-name" id="profileName">Loading...</h1>
                                    <p class="profile-title" id="profileTitle"></p>
                                    <p class="profile-bio" id="profileBio"></p>
                                    <div class="profile-stats">
                                        <div class="stat-number-wrapper">
                                            <span class="stat-number" id="postCount">0</span>
                                            <span class="stat-label">Posts</span>
                                        </div>
                                        <div class="profile-stat">
                                            <span class="stat-number" id="followerCount">0</span>
                                            <span class="stat-label">Followers</span>
                                        </div>
                                        <div class="profile-stat">
                                            <span class="stat-number" id="followingCount">0</span>
                                            <span class="stat-label">Following</span>
                                        </div>
                                    </div>
                                    <div class="profile-actions" id="profileActions">
                                        <!-- Buttons will be dynamically added -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="profile-tabs">
                            <div class="profile-tab active" data-tab="posts">
                                <i class="fas fa-th-large"></i> Posts
                            </div>
                            <div class="profile-tab" data-tab="reels">
                                <i class="fas fa-film"></i> Reels
                            </div>
                            <div class="profile-tab" data-tab="saved">
                                <i class="fas fa-bookmark"></i> Saved
                            </div>
                        </div>
                        <div id="profileContent">
                            <!-- Profile content will be loaded here -->
                        </div>
                    </div>

                    <!-- Followers Page -->
                    <div class="feed user-list-page" id="followersPage" style="display: none;">
                        <h2>Followers</h2>
                        <div id="followersListContainer">
                            <!-- Followers will be loaded here -->
                        </div>
                    </div>

                    <!-- Following Page -->
                    <div class="feed user-list-page" id="followingPage" style="display: none;">
                        <h2>Following</h2>
                        <div id="followingListContainer">
                            <!-- Following will be loaded here -->
                        </div>
                    </div>

                    <!-- Settings Page -->
                    <div class="feed" id="settingsPage" style="display: none;">
                        <div class="message-section" style="box-shadow: none; background-color: transparent; padding:0;"> <!-- Removed default section styling -->
                            <h3 class="message-section-title" style="padding: 0 0 15px 0;">General Settings</h3> <!-- Adjusted padding -->
                            <button class="settings-btn" id="shareProfileBtn"><i class="fas fa-share-alt"></i> <span>Share Profile</span></button>
                            <button class="settings-btn" id="accountSettingsBtn"><i class="fas fa-user-cog"></i> <span>Account Settings</span></button>
                            <button class="settings-btn" id="privacySettingsBtn"><i class="fas fa-user-secret"></i> <span>Privacy Settings</span></button> <!-- New Privacy Button -->
                            <button class="settings-btn" id="appSettingsBtn"><i class="fas fa-mobile-alt"></i> <span>App Settings</span></button>
                            <button class="settings-btn" id="swavotiVerificationBtn"><i class="fas fa-check"></i> <span>Swavoti Verification</span></button>

                            <h4 class="message-section-title" style="padding: 20px 0 15px 0; margin-top:10px; border-top: 1px solid #eee;">More Options</h4>
                            <button class="settings-btn" id="downloadDataBtn"><i class="fas fa-download"></i> <span>Download Your Data</span></button>
                            <a href="mailto:support@swavoti.co.za" class="settings-btn"><i class="fas fa-headset"></i> <span>Support</span></a>
                            <button class="settings-btn" id="legalBtn"><i class="fas fa-gavel"></i> <span>Legal</span></button>

                            <button class="settings-btn" id="moreSettingsBtn" style="display:none;"><i class="fas fa-ellipsis-h"></i> <span>More...</span></button> <!-- Hiding original more button for now -->
                            <button class="settings-btn danger" id="logoutBtn" style="margin-top: 30px;"><i class="fas fa-sign-out-alt"></i> <span>Logout</span></button>
                        </div>
                        <!-- Removed inline privacy settings from here -->
                    </div>

                    <!-- Privacy Settings Page -->
                    <div class="feed" id="privacySettingsPage" style="display: none;">
                        <div class="modal-header" style="background-color: var(--light-color); border-bottom: 1px solid #ddd; position: sticky; top: 0; z-index:10;">
                            <button class="back-btn" id="privacySettingsBackBtn" style="background:none; border:none; font-size:20px; color:var(--dark-color); cursor:pointer;"><i class="fas fa-arrow-left"></i></button>
                            <h3 class="modal-title" style="flex-grow:1; text-align:center; color:var(--primary-color);">Privacy Settings</h3>
                            <div style="width:40px;"></div> <!-- Spacer -->
                        </div>
                        <div style="padding: 20px;">
                            <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 8px; margin-bottom:15px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display:flex; justify-content:space-between; align-items:center;">
                                <label for="privacyOnlineStatus" style="font-weight:500;">Online Status Visibility</label>
                                <select id="privacyOnlineStatus" class="privacy-select" style="padding:8px 10px; border:1px solid #ddd; border-radius:5px; background-color:white; min-width:150px;">
                                    <option value="everyone">Everyone</option>
                                    <option value="followers">Followers Only</option>
                                    <option value="nobody">Nobody</option>
                                </select>
                            </div>
                            <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 8px; margin-bottom:15px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display:flex; justify-content:space-between; align-items:center;">
                                <label for="privacyStoryVisibility" style="font-weight:500;">Story Visibility</label>
                                <select id="privacyStoryVisibility" class="privacy-select" style="padding:8px 10px; border:1px solid #ddd; border-radius:5px; background-color:white; min-width:150px;">
                                    <option value="everyone">Everyone</option>
                                    <option value="followers">Followers Only</option>
                                </select>
                            </div>
                            <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 8px; margin-bottom:15px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display:flex; justify-content:space-between; align-items:center;">
                                <label for="privacyCommentPermissions" style="font-weight:500;">Who Can Comment</label>
                                <select id="privacyCommentPermissions" class="privacy-select" style="padding:8px 10px; border:1px solid #ddd; border-radius:5px; background-color:white; min-width:150px;">
                                    <option value="everyone">Everyone</option>
                                    <option value="followers">Followers Only</option>
                                </select>
                            </div>
                            <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 8px; margin-bottom:15px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display:flex; justify-content:space-between; align-items:center;">
                                <label for="privacyAccountType" style="font-weight:500;">Account Type</label>
                                <select id="privacyAccountType" class="privacy-select" style="padding:8px 10px; border:1px solid #ddd; border-radius:5px; background-color:white; min-width:150px;">
                                    <option value="public">Public</option>
                                    <option value="private">Private</option>
                                </select>
                            </div>
                        </div>
                    </div>


                    <!-- Reels Search Page -->
                    <div class="feed" id="reelsSearchPage" style="display: none;">
                        <div class="reels-search-header">
                            <button class="back-btn" id="reelsSearchBackBtn"><i class="fas fa-arrow-left"></i></button>
                            <h3>Search Reels</h3>
                        </div>
                        <div class="search-input-wrapper" style="padding: 15px;">
                             <i class="fas fa-search"></i>
                            <input type="text" id="reelsSearchInput" placeholder="Search for reels...">
                        </div>
                        <div id="reelsSearchResultsContainer" class="explore-reels-grid" style="flex-grow: 1; overflow-y: auto; padding: 0 15px 15px 15px;">
                            <!-- Reels search results will be loaded here -->
                        </div>
                    </div>


                    <!-- Search Page -->
                    <div class="feed" id="searchPage" style="display: none;">
                        <div class="search-page-container">
                            <div class="search-input-wrapper">
                                <i class="fas fa-search"></i>
                                <input type="text" id="searchInput" placeholder="Search posts, reels, users, tags...">
                            </div>
                            <div class="search-filters">
                                <button class="search-filter-btn active" data-filter="all">All</button>
                                <button class="search-filter-btn" data-filter="posts">Posts</button>
                                <button class="search-filter-btn" data-filter="reels">Reels</button>
                                <button class="search-filter-btn" data-filter="users">Users</button>
                            </div>
                            <div id="searchResultsContainer" class="search-results-container">
                                <!-- Search results will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Swavoti Verification Page -->
                    <div class="feed" id="swavotiVerificationPage" style="display: none; padding: 20px;">
                        <h3 class="page-title" style="text-align: center; color: var(--primary-color); margin-bottom: 20px;">Swavoti Verification</h3>
                        <div id="verificationStatusContainer">
                            <!-- Status, buttons, and iframes will be managed here by JS -->
                        </div>
                        <!-- Container for the first iframe (apply for verification) -->
                        <div id="applyVerificationIframeModal" class="modal" style="display: none; background-color: rgba(0,0,0,0.7);">
                            <div class="modal-content" style="max-width: 90%; max-height: 90vh; width:auto; height:auto; padding:0; position:relative; background-color:transparent; box-shadow:none;">
                                <button class="close-modal" id="closeApplyVerificationIframe" style="position:absolute; top:10px; right:10px; font-size:24px; color:white; background-color:rgba(0,0,0,0.5); border-radius:50%; width:30px; height:30px; line-height:30px; text-align:center; z-index:10;">&times;</button>
                                <iframe id="applyVerificationIframe" style="width: 80vw; height: 80vh; border: none; border-radius:10px; background-color:white;"></iframe>
                            </div>
                        </div>
                        <!-- Container for the second iframe (proceed to checkout) - will be embedded, not a modal -->
                        <div id="checkoutIframeContainer" style="display: none; width:100%; height: calc(100vh - 120px - 40px); /* Full height minus header, bottom-nav and padding */ margin-top:20px;">
                             <iframe id="checkoutIframe" style="width: 100%; height: 100%; border: none;"></iframe>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Reels Fullscreen View -->
        <div class="reels-container" id="reelsContainer">
            <div class="reels-header">
                <button class="back-btn" id="reelsHeaderBackBtn"><i class="fas fa-arrow-left"></i></button>
                <h3 style="margin: 0;">Reels</h3>
                <button class="search-btn" id="reelsHeaderSearchBtn"><i class="fas fa-search"></i></button>
            </div>
             <!-- Reel items will be dynamically added here -->
        </div>


        <!-- Story Preview Modal -->
        <div class="story-modal" id="storyModal">
            <div class="story-modal-content">
                <span class="close-story-modal" id="closeStoryModal">&times;</span>
                <div class="story-user-info">
                    <img id="storyUserAvatar" src="" alt="User">
                    <span id="storyUsername"></span>
                </div>
                <img id="storyImage" class="story-media" style="display: none;">
                <video id="storyVideo" class="story-media" autoplay playsinline style="display: none;"></video>

                <i class="fas fa-chevron-left story-nav-arrow" id="prevStoryBtn" style="display: none;"></i>
                <i class="fas fa-chevron-right story-nav-arrow" id="nextStoryBtn" style="display: none;"></i>

                <div class="story-actions-bottom">
                    <input type="text" id="storyReplyInput" placeholder="Reply to story...">
                    <button id="storyLikeBtn"><i class="far fa-heart"></i></button>
                    <button id="storySendReplyBtn"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
        </div>


        <!-- Bottom Navigation - Mobile -->
        <div class="bottom-nav" id="bottomNav">
            <a href="#home" class="nav-icon active" data-page="home">
                <i class="fas fa-home"></i>
                <span>Home</span>
            </a>
            <a href="#explore" class="nav-icon" data-page="explore">
                <i class="fas fa-compass"></i>
                <span>Discover</span>
            </a>
            <a href="#" class="plus-button" id="mobileCreatePostBtn">
                <i class="fas fa-plus"></i>
            </a>
            <a href="#reels" class="nav-icon" data-page="reels" id="mobileReelsBtn">
                <i class="fas fa-film"></i>
                <span>Reels</span>
            </a>
            <a href="#profile" class="nav-icon" data-page="profile">
                <i class="fas fa-user"></i>
                <span>Profile</span>
            </a>
        </div>

        <!-- Create Post Modal -->
        <div class="modal" id="createPostModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Create Post</div>
                    <button class="close-modal" id="closeModal">&times;</button>
                </div>
                <div class="modal-body">
                    <form class="post-form" id="postForm">
                        <!-- Step 1: Content Creation -->
                        <div id="createPostStep1">
                            <div class="post-user" style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                                <img id="modal-profile-img" src="https://ui-avatars.com/api/?name=User&background=random" alt="User" style="width:45px; height:45px;">
                                <div class="post-user-info">
                                    <h4 id="modal-profile-name" style="font-size: 16px;">User</h4>
                                    <!-- Visibility removed from here, will be in step 2 -->
                                </div>
                            </div>
                            <textarea placeholder="Share your thoughts, @mention, #hashtag..." id="postText" style="min-height: 120px; font-size:18px; border:none; margin-bottom:10px;"></textarea>

                            <div class="preview-container" id="previewContainer" style="display: none; margin-bottom: 15px; background-color: #f0f0f0; border-radius: 8px; padding:10px;">
                                <!-- Thumbnails for multiple images will go here -->
                                <div id="multipleImagePreview" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom:10px;"></div>

                                <img id="previewImage" class="preview-image" style="display: none; max-height:250px;" onerror="this.onerror=null; this.src='https://placehold.co/300x200/cccccc/333333?text=Image+Load+Error';">
                                <video id="previewVideo" class="preview-video" controls style="display: none; max-height:250px;" onerror="this.onerror=null; this.src='https://placehold.co/300x200/cccccc/333333?text=Video+Load+Error';">
                                    <source src="" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                                <button type="button" class="remove-preview" id="removePreview" style="position:absolute; top:5px; right:5px; z-index:10;">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>

                            <!-- Post Type Selection -->
                            <div class="form-group" style="margin-bottom: 15px;">
                                <label for="postType" style="font-weight:500; display:block; margin-bottom:8px;">Post Type:</label>
                                <select id="postType" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:5px; background-color:white;">
                                    <option value="post">Standard Post</option>
                                    <option value="reel">Reel (Video Only)</option>
                                    <option value="story">Story (Image Only, 24hr)</option>
                                </select>
                            </div>

                            <!-- Tags Input -->
                            <div class="form-group" style="margin-bottom: 15px;">
                                <label for="postTags" style="font-weight:500; display:block; margin-bottom:8px;">Tags (comma-separated):</label>
                                <input type="text" id="postTags" placeholder="e.g., #tech, #innovation" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:5px;">
                                <div id="tagsDisplay" class="tags-display" style="margin-top:8px;"></div>
                            </div>

                            <div class="post-options-bar" style="border-top: 1px solid #eee; padding-top: 15px; margin-top:20px;">
                                <div class="add-to-post">
                                    <div class="add-option" id="addPhoto" style="padding:8px 12px; border-radius:20px; background-color: #e7f3ff; color:var(--primary-color)">
                                        <i class="fas fa-image"></i>
                                        <span style="margin-left:5px;">Photo/Gallery</span>
                                        <input type="file" id="photoUpload" accept="image/*" style="display: none;" multiple>
                                    </div>
                                    <div class="add-option" id="addVideo" style="padding:8px 12px; border-radius:20px; background-color: #e2ffe8; color:var(--success-color);">
                                        <i class="fas fa-video"></i>
                                        <span style="margin-left:5px;">Video</span>
                                        <input type="file" id="videoUpload" accept="video/*" style="display: none;">
                                    </div>
                                </div>
                                <button type="button" class="post-submit-btn primary-btn" id="postNextBtn" style="opacity:1; background: var(--primary-color); color:white; padding: 10px 20px;">Next</button>
                            </div>
                        </div>

                        <!-- Step 2: Scheduling & Finalization -->
                        <div id="createPostStep2" style="display: none; padding-top:15px;">
                            <h4 style="margin-bottom:15px; color: var(--primary-color); font-size:18px; text-align:center;">Finalize Your Post</h4>

                            <div class="form-group" style="margin-bottom: 15px;">
                                <label for="postLocation" style="font-weight:500; display:block; margin-bottom:8px;">Location (Optional):</label>
                                <input type="text" id="postLocation" placeholder="e.g., New York, USA" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:5px;">
                            </div>

                            <div class="form-group" style="margin-bottom: 15px;">
                                <label for="postVisibility" style="font-weight:500; display:block; margin-bottom:8px;">Visibility:</label>
                                <select id="postVisibility" style="width:100%; padding:10px; border:1px solid #ddd; border-radius:5px; background-color:white;">
                                    <option value="public">Public</option>
                                    <option value="followers">Followers Only</option>
                                    <option value="private">Private (Only You)</option>
                                </select>
                            </div>

                            <div class="form-group monetization-options" id="monetizationOptions" style="display: none; margin-bottom: 15px; background-color: #f9f9f9; padding:10px; border-radius:5px;">
                                <label style="display:flex; align-items:center;">
                                    <input type="checkbox" id="enableMonetization" style="margin-right:8px;"> Enable Monetization
                                </label>
                                <p style="font-size: 12px; color: var(--gray-color); margin-top: 5px;">
                                    Allow users to support this post financially (only for 'Standard Post' type).
                                </p>
                            </div>

                            <div class="form-group scheduling-options" style="margin-bottom: 20px;">
                                <label for="scheduleDateTime" style="font-weight:500; display:block; margin-bottom:8px;">Schedule Post (Optional):</label>
                                <input type="datetime-local" id="scheduleDateTime" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom:5px;">
                                <button type="button" id="clearScheduleBtn" style="font-size: 12px; color: var(--danger-color); background: none; border: none; cursor: pointer; padding:5px 0;">Clear Schedule</button>
                            </div>

                            <div class="post-options-bar" style="border-top: 1px solid #eee; padding-top: 15px; display:flex; justify-content: space-between; margin-top:20px;">
                                <button type="button" class="secondary-btn" id="postBackBtn" style="padding: 10px 20px;">Back</button>
                                <button type="submit" class="post-submit-btn primary-btn" id="postSubmitBtn" style="opacity:1; background: var(--accent-color); color:white; padding: 10px 20px;">Post Now</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- Comment Modal -->
        <div class="modal" id="commentModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Comments</div>
                    <button class="close-modal" id="closeCommentModal">&times;</button>
                </div>
                <div class="modal-body">
                    <div id="commentsList" style="flex-grow: 1; overflow-y: auto; padding-bottom: 15px;">
                        <!-- Comments will be loaded here -->
                    </div>
                    <form id="commentForm" style="display: flex; align-items: center; border-top: 1px solid #eee; padding-top: 15px;">
                        <img id="comment-profile-img" src="https://ui-avatars.com/api/?name=User&background=random" alt="User" width="40" style="margin-right:10px; border-radius: 50%;">
                        <input type="text" id="commentText" placeholder="Write a comment..." style="flex-grow: 1; padding: 10px; border: 1px solid #ddd; border-radius: 20px; outline: none; margin-right: 10px;">
                        <button type="submit" class="post-submit-btn" style="padding: 10px 15px; border-radius: 20px; opacity: 1;">Post</button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Edit Profile Modal -->
        <div class="modal" id="editProfileModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Edit Profile</div>
                    <button class="close-modal" id="closeEditProfileModal">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Step 1: Edit Name, Title, Bio -->
                    <div class="edit-profile-step" id="editProfileStep1">
                        <h3>Personal Information</h3>
                        <label for="editNameInput" style="display: block; text-align: left; margin-bottom: 5px;">Full Name</label>
                        <input type="text" id="editNameInput" placeholder="Your Full Name">
                        <label for="editTitleInput" style="display: block; text-align: left; margin-bottom: 5px;">Title/Profession</label>
                        <input type="text" id="editTitleInput" placeholder="e.g., Software Engineer">
                        <label for="editBioInput" style="display: block; text-align: left; margin-bottom: 5px;">About Me</label>
                        <textarea id="editBioInput" placeholder="Tell us about yourself..."></textarea>
                        <div class="btn-group">
                            <button class="secondary-btn" id="skipNameEdit">Skip</button>
                            <button class="primary-btn" id="saveNameEdit">Save & Next</button>
                        </div>
                    </div>

                    <!-- Step 2: Edit Profile Picture -->
                    <div class="edit-profile-step" id="editProfileStep2">
                        <h3>Edit Profile Picture</h3>
                        <img id="editProfilePicPreview" class="profile-pic-preview" src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile Picture">
                        <input type="file" id="editProfilePicUpload" accept="image/*" style="display: none;">
                        <button class="secondary-btn" id="uploadProfilePicBtn">Upload New Picture</button>
                        <div class="btn-group">
                            <button class="secondary-btn" id="prevProfilePicEdit">Previous</button>
                            <button class="primary-btn" id="saveProfilePicEdit">Save</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Share Modal -->
        <div class="modal" id="shareModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Share Post</div>
                    <button class="close-modal" id="closeShareModal">&times;</button>
                </div>
                <div class="modal-body" style="display: flex; flex-direction: column; overflow-y: auto;">
                    <div class="share-options">
                        <button id="shareWhatsapp"><i class="fab fa-whatsapp"></i> Share on WhatsApp</button>
                        <button id="shareFacebook"><i class="fab fa-facebook"></i> Share on Facebook</button>
                        <button id="copyLink"><i class="fas fa-copy"></i> Copy Link</button>
                    </div>
                    <hr style="margin: 20px 0; border: 1px solid #eee;">
                    <h4>Send to a conversation:</h4>
                    <div id="shareUserList" style="flex-grow: 1; overflow-y: auto; margin-top: 15px;">
                        <!-- User list will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Modal -->
        <div class="chat-modal" id="chatModal">
            <div class="chat-modal-content">
                <div class="chat-header">
                    <img id="chatPartnerAvatar" src="https://ui-avatars.com/api/?name=User&background=random" alt="User">
                    <h4 id="chatPartnerName"></h4>
                    <span id="chatPartnerOnlineStatus" class="online-status"></span>
                    <span id="chatTypingIndicator" class="online-status" style="display: none;">typing...</span>
                    <button class="close-chat-modal" id="closeChatModal">&times;</button>
                </div>
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will be loaded here -->
                </div>
                 <div class="chat-encryption-notice" style="padding: 5px 15px; text-align: center; font-size: 11px; color: var(--gray-color); background-color: var(--light-color); border-top: 1px solid #eee;">
                    <i class="fas fa-lock" style="margin-right: 5px;"></i> Chats are end-to-end encrypted.
                </div>
                <div id="chatMediaPreviewContainer" style="display: none;">
                    <img id="chatImagePreview" style="display: none;">
                    <button type="button" id="removeChatMediaPreview" style="display: none;">&times;</button>
                </div>
                <form class="chat-input" id="chatInputForm">
                    <input type="text" id="chatMessageInput" placeholder="Type a message...">
                    <button type="button" id="chatImageUploadBtn" class="chat-action-btn"><i class="fas fa-image"></i></button>
                    <input type="file" id="chatImageInput" accept="image/*" style="display: none;">
                    <button type="submit" id="chatSendButton" class="chat-action-btn" style="background-color: var(--primary-color); color: white; width: 40px; height: 40px; border-radius: 50%;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
            </div>
        </div>

        <!-- Account Settings Modal -->
        <div class="modal" id="accountSettingsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Account Settings</div>
                    <button class="close-modal" id="closeAccountSettingsModal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="profile-summary">
                        <img id="accountSettingsAvatar" src="" alt="Profile">
                        <div>
                            <h4 id="accountSettingsName"></h4>
                            <p id="accountSettingsEmail"></p>
                            <p>Balance: <strong id="accountSettingsBalance">ZAR 0.00</strong></p>
                        </div>
                    </div>

                    <h4 style="margin-bottom: 15px; text-align: left; color: var(--primary-color);">Security</h4>
                    <div class="security-options">
                        <div class="security-option" id="resetPasswordBtn">
                            <span>Reset Password</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="security-option" id="changeEmailBtn">
                            <span>Change Email</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item">
                            <span>Online Status</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="onlineStatusToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <span>Read Receipts</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="readReceiptsToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <h4 style="margin-top: 20px; margin-bottom: 15px; text-align: left; color: var(--primary-color);">Preferences</h4>
                    <div class="setting-item" id="blockedUsersBtn">
                        <span>Blocked Users</span>
                        <i class="fas fa-user-slash"></i>
                    </div>
                    <div class="setting-item" id="notificationPreferencesBtn">
                        <span>Notification Preferences</span>
                        <i class="fas fa-bell"></i>
                    </div>
                    <div class="setting-item">
                        <span>Dark Theme</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="darkThemeToggle">
                            <span class="slider"></span>
                        </label>
                    </div>

                </div>
            </div>
        </div>

        <!-- App Settings Modal -->
        <div class="modal" id="appSettingsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">App Settings</div>
                    <button class="close-modal" id="closeAppSettingsModal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="setting-item">
                        <span>Language</span>
                        <span>English <i class="fas fa-chevron-right"></i></span>
                    </div>
                    <h4 style="margin-top: 20px; margin-bottom: 15px; text-align: left; color: var(--primary-color);">Storage & Cache</h4>
                    <div class="setting-item" id="clearCacheBtn">
                        <span>Clear Cache</span>
                        <i class="fas fa-trash-alt"></i>
                    </div>

                    <h4 style="margin-top: 20px; margin-bottom: 15px; text-align: left; color: var(--primary-color);">About the App</h4>
                    <div class="setting-item">
                        <span>App Version</span>
                        <span>Swavoti v4.7.8</span>
                    </div>
                    <div class="setting-item" id="sendFeedbackBtn">
                        <span>Send Feedback</span>
                        <i class="fas fa-paper-plane"></i>
                    </div>
                </div>
            </div>
        </div>

        <!-- Swavoti Verification Page (Replaces Modal) -->
        <!-- Content for this page will be added in subsequent steps -->
        <!-- The main container for the page content will be within the main #contentArea -->

        <!-- Media Management Page -->
        <div class="feed" id="manageMediaPage" style="display: none;">
            <div class="modal-header" style="background-color: var(--light-color); border-bottom: 1px solid #ddd; position: sticky; top: 0; z-index:10;">
                <button class="back-btn" id="mediaManagerBackBtn" style="background:none; border:none; font-size:20px; color:var(--dark-color); cursor:pointer;"><i class="fas fa-arrow-left"></i></button>
                <h3 class="modal-title" style="flex-grow:1; text-align:center; color:var(--primary-color);">Manage Media</h3>
                <div style="width:40px;"></div> <!-- Spacer -->
            </div>
            <div id="mediaGridContainer" style="padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;">
                <!-- Media items will be loaded here -->
            </div>
        </div>

        <!-- Edit Post Modal -->
        <div class="modal" id="editPostModal">
            <div class="modal-content" style="max-width: 500px; height: auto; border-radius: 10px;">
                <div class="modal-header">
                    <div class="modal-title">Edit Post</div>
                    <button class="close-modal" id="closeEditPostModal">&times;</button>
                </div>
                <div class="modal-body">
                    <form id="editPostForm">
                        <textarea id="editPostText" style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;"></textarea>
                        <button type="submit" class="profile-btn primary-btn" style="width: 100%;">Save Changes</button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Post Options Bottom Sheet Modal -->
        <div class="modal" id="postOptionsModal">
            <div class="modal-content" id="postOptionsModalContent" style="width: 100%; max-width: 100%; height: auto; position: absolute; bottom: 0; left: 0; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; animation: slideUp 0.3s ease-out; padding: 20px; text-align: left;">
                <!-- Options will be populated by JS -->
            </div>
        </div>

        <!-- Notification Options Bottom Sheet Modal -->
        <div class="modal" id="notificationOptionsModal">
            <div class="modal-content" id="notificationOptionsModalContent" style="width: 100%; max-width: 100%; height: auto; position: absolute; bottom: 0; left: 0; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; animation: slideUp 0.3s ease-out; padding: 20px; text-align: left;">
                <!-- Options will be populated by JS -->
            </div>
        </div>

        <!-- Feedback Modal -->
        <div class="modal" id="feedbackModal">
            <div class="modal-content" style="max-width: 500px; height: auto; border-radius: 10px;">
                <div class="modal-header">
                    <div class="modal-title">Send Feedback</div>
                    <button class="close-modal" id="closeFeedbackModal">&times;</button>
                </div>
                <div class="modal-body">
                    <form id="feedbackForm">
                        <textarea id="feedbackText" placeholder="Your feedback is valuable to us..." style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;"></textarea>
                        <button type="submit" class="profile-btn primary-btn" style="width: 100%;">Submit Feedback</button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Support Creator Modal -->
        <div class="modal" id="supportCreatorModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Support Creator</div>
                    <button class="close-modal" id="closeSupportCreatorModal">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="text-align: center; margin-bottom: 20px;">Choose an amount to support this creator:</p>
                    <div class="support-price-options">
                        <button class="support-price-btn primary-btn" data-amount="20">ZAR 20</button>
                        <button class="support-price-btn primary-btn" data-amount="50">ZAR 50</button>
                        <button class="support-price-btn primary-btn" data-amount="100">ZAR 100</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Payment Modal -->
        <div class="modal" id="paymentModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Payment</div>
                    <button class="close-modal" id="closePaymentModal">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="text-align: center; margin-bottom: 20px;">You are supporting the creator with <strong id="paymentAmountDisplay"></strong>.</p>
                    <div style="text-align: center; margin-bottom: 20px; font-size: 14px; color: var(--gray-color);">
                        Powered by Stripe
                    </div>
                    <button class="primary-btn" id="payNowSupportBtn">Pay Now</button>
                    <p id="paymentSupportError" style="color: var(--danger-color); margin-top: 10px; text-align: center;"></p>
                </div>
            </div>
        </div>

    </div>

    <!-- Notification Toast -->
    <div id="notificationToast" class="notification-toast"></div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="confirm-modal">
        <div class="confirm-modal-content">
            <p id="confirmModalText"></p>
            <div class="confirm-modal-buttons">
                <button id="confirmBtnNo">Cancel</button>
                <button id="confirmBtnYes">Confirm</button>
            </div>
        </div>
    </div>

    <!-- User Mentions Dropdown -->
    <div id="mentionsDropdown" class="mentions-dropdown" style="display: none;">
        <!-- Usernames will be populated here -->
    </div>

    <!-- New Group Modal -->
    <div class="modal" id="newGroupModal">
        <div class="modal-content" style="max-width: 500px; height: auto; min-height: 300px; max-height: 90vh; border-radius: 10px;">
            <div class="modal-header">
                <div class="modal-title" id="newGroupModalTitle">Create New Group</div>
                <button class="close-modal" id="closeNewGroupModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Step 1: Select Users -->
                <div id="newGroupStep1">
                    <h3 style="text-align: center; margin-bottom: 15px; color: var(--primary-color);">Select Members</h3>
                    <div class="search-input-wrapper" style="margin-bottom: 15px;">
                        <i class="fas fa-search" style="top: 50%; transform: translateY(-50%);"></i>
                        <input type="text" id="newGroupMemberSearch" placeholder="Search users you follow..." style="padding-left: 40px; border-radius: 20px;">
                    </div>
                    <div id="newGroupUserList" style="max-height: 250px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #eee; padding: 10px; border-radius: 5px;">
                        <!-- Users will be populated here by JS -->
                        <p style="text-align:center; color: var(--gray-color);">Loading users you follow...</p>
                    </div>
                    <div style="display: flex; justify-content: flex-end;">
                        <button class="profile-btn primary-btn" id="newGroupNextBtn">Next</button>
                    </div>
                </div>

                <!-- Step 2: Group Details -->
                <div id="newGroupStep2" style="display: none;">
                    <h3 style="text-align: center; margin-bottom: 20px; color: var(--primary-color);">Group Details</h3>
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label for="newGroupName" style="font-weight: 500; display: block; margin-bottom: 5px;">Group Name*</label>
                        <input type="text" id="newGroupName" placeholder="Enter group name" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                    </div>
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label for="newGroupIcon" style="font-weight: 500; display: block; margin-bottom: 5px;">Group Icon (Optional)</label>
                        <input type="file" id="newGroupIconUpload" accept="image/*" style="display: block; margin-bottom: 10px;">
                        <img id="newGroupIconPreview" src="#" alt="Group Icon Preview" style="max-width: 100px; max-height: 100px; border-radius: 50%; object-fit: cover; display: none; margin: 0 auto 10px;">
                    </div>
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label for="newGroupDescription" style="font-weight: 500; display: block; margin-bottom: 5px;">Description (Optional)</label>
                        <textarea id="newGroupDescription" placeholder="Enter group description" style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; resize: vertical;"></textarea>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <button class="profile-btn secondary-btn" id="newGroupBackBtn">Back</button>
                        <button class="profile-btn primary-btn" id="saveNewGroupBtn">
                            <i class="fas fa-save" style="margin-right: 5px;"></i> Save Group
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBI0WSJdoZf4WF2hJuXZ1PYKpRDiQrbcqA",
            authDomain: "swavoti.firebaseapp.com",
            databaseURL: "https://swavoti-default-rtdb.firebaseio.com",
            projectId: "swavoti",
            storageBucket: "swavoti.firebasestorage.app",
            messagingSenderId: "540194845433",
            appId: "1:540194845433:web:c2834d029cfe45fcaa2828",
            measurementId: "G-LT252GHZQ6"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // Thumbsnap API Key
        const THUMBSNAP_API_KEY = '000465b4d0c2c9914d9165b87a6b5e40';
        const THUMBSNAP_UPLOAD_URL = 'https://thumbsnap.com/api/upload';

        // Helper function to hide overlay after a delay
        function hideOverlayAfterDelay(overlayElement, delayInMilliseconds) {
            if (overlayElement) {
                setTimeout(() => {
                    overlayElement.classList.add('hidden');
                }, delayInMilliseconds);
            }
        }

        // DOM Elements
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const signupContainer = document.getElementById('signup-container');
        const loginContainer = document.getElementById('login-container');
        const signupForm = document.getElementById('newSignupForm'); // Updated ID
        const loginForm = document.getElementById('newLoginForm'); // Updated ID
        // const showLogin = document.getElementById('show-login'); // Old, removed
        // const showSignup = document.getElementById('show-signup'); // Old, removed
        const signupError = document.getElementById('new-signup-error'); // Updated ID
        const loginError = document.getElementById('new-login-error'); // Updated ID
        const userProfile = document.getElementById('user-profile');
        const usernameDisplay = document.getElementById('username-display');
        const notificationCount = document.getElementById('notificationCount');
        const messageCount = document.getElementById('messageCount');
        const searchIconMobile = document.getElementById('searchIconMobile');
        const notificationIcon = document.getElementById('notificationIcon');
        const messageIcon = document.getElementById('messageIcon');
        const bottomNav = document.getElementById('bottomNav');

        // Content containers
        const homeFeed = document.getElementById('homeFeed');
        const exploreContent = document.getElementById('exploreContent');
        // const exploreFilterButton = document.getElementById('exploreFilterButton'); // Old button, removed
        const exploreTabButtons = document.querySelectorAll('.explore-tab-btn');
        const forYouViewContent = document.getElementById('forYouViewContent');
        const popularReelsContainer = document.getElementById('popularReelsContainer');
        const popularPostsContainer = document.getElementById('popularPostsContainer');
        const exploreHashtagsViewContent = document.getElementById('exploreHashtagsViewContent');
        const exploreHashtagsContainer = document.getElementById('exploreHashtagsContainer');

        let currentExploreView = 'forYou'; // 'forYou' or 'exploreHashtags'
        let lastVisiblePopularPost = null; // For "For You" popular posts pagination
        let lastVisibleTaggedPost = null;  // For "Explore Hashtags" pagination
        const EXPLORE_POSTS_PER_BATCH = 9; // For grid layouts

        const notificationsList = document.getElementById('notificationsList');
        // const followingList = document.getElementById('followingList'); // Removed
        const conversationsList = document.getElementById('conversationsList');
        const settingsPage = document.getElementById('settingsPage');
        const searchPage = document.getElementById('searchPage');
        const reelsSearchPage = document.getElementById('reelsSearchPage'); // New Reels Search Page

        // Profile elements
        const profileName = document.getElementById('profileName');
        const profileTitle = document.getElementById('profileTitle');
        const profileBio = document.getElementById('profileBio');
        const profileAvatar = document.getElementById('profileAvatar');
        const postCount = document.getElementById('postCount');
        const followerCount = document.getElementById('followerCount');
        const followingCount = document.getElementById('followingCount');
        const profileActions = document.getElementById('profileActions');
        const profileContent = document.getElementById('profileContent');
        const followersListContainer = document.getElementById('followersListContainer');
        const followingListContainer = document.getElementById('followingListContainer');

        // Reels elements
        const reelsContainer = document.getElementById('reelsContainer');
        const mobileReelsBtn = document.getElementById('mobileReelsBtn');

        // Create post elements
        const postTypeSelect = document.getElementById('postType');
        const monetizationOptions = document.getElementById('monetizationOptions');
        const enableMonetizationCheckbox = document.getElementById('enableMonetization');
        const photoUpload = document.getElementById('photoUpload');
        const videoUpload = document.getElementById('videoUpload');
        const postTagsInput = document.getElementById('postTags');
        const tagsDisplay = document.getElementById('tagsDisplay');
        const postLocationInput = document.getElementById('postLocation');
        const postVisibilitySelect = document.getElementById('postVisibility');


        // Story modal elements
        const storyModal = document.getElementById('storyModal');
        const closeStoryModal = document.getElementById('closeStoryModal');
        const storyUserAvatar = document.getElementById('storyUserAvatar');
        const storyUsername = document.getElementById('storyUsername');
        const storyImage = document.getElementById('storyImage');
        const storyVideo = document.getElementById('storyVideo');
        const storyReplyInput = document.getElementById('storyReplyInput');
        const storyLikeBtn = document.getElementById('storyLikeBtn');
        const storySendReplyBtn = document.getElementById('storySendReplyBtn');
        const prevStoryBtn = document.getElementById('prevStoryBtn');
        const nextStoryBtn = document.getElementById('nextStoryBtn');

        // Chat modal elements
        const chatModal = document.getElementById('chatModal');
        const closeChatModal = document.getElementById('closeChatModal');
        const chatPartnerAvatar = document.getElementById('chatPartnerAvatar');
        const chatPartnerName = document.getElementById('chatPartnerName');
        const chatMessages = document.getElementById('chatMessages');
        const chatInputForm = document.getElementById('chatInputForm');
        const chatMessageInput = document.getElementById('chatMessageInput');
        const chatImageUploadBtn = document.getElementById('chatImageUploadBtn');
        const chatImageInput = document.getElementById('chatImageInput');
        const chatMediaPreviewContainer = document.getElementById('chatMediaPreviewContainer');
        const chatImagePreview = document.getElementById('chatImagePreview');
        const removeChatMediaPreview = document.getElementById('removeChatMediaPreview');
        const chatSendButton = document.getElementById('chatSendButton');
        const chatTypingIndicator = document.getElementById('chatTypingIndicator');
        const chatPartnerOnlineStatus = document.getElementById('chatPartnerOnlineStatus');

        // Edit Profile Modal Elements
        const editProfileModal = document.getElementById('editProfileModal');
        const closeEditProfileModal = document.getElementById('closeEditProfileModal');
        const editProfileStep1 = document.getElementById('editProfileStep1');
        const editProfileStep2 = document.getElementById('editProfileStep2');
        const editNameInput = document.getElementById('editNameInput');
        const editTitleInput = document.getElementById('editTitleInput');
        const editBioInput = document.getElementById('editBioInput');
        const skipNameEdit = document.getElementById('skipNameEdit');
        const saveNameEdit = document.getElementById('saveNameEdit');
        const editProfilePicPreview = document.getElementById('editProfilePicPreview');
        const editProfilePicUpload = document.getElementById('editProfilePicUpload');
        const uploadProfilePicBtn = document.getElementById('uploadProfilePicBtn');
        const prevProfilePicEdit = document.getElementById('prevProfilePicEdit');
        const saveProfilePicEdit = document.getElementById('saveProfilePicEdit');

        // Share Modal Elements
        const shareModal = document.getElementById('shareModal');
        const closeShareModal = document.getElementById('closeShareModal');
        const shareWhatsappBtn = document.getElementById('shareWhatsapp');
        const shareFacebookBtn = document.getElementById('shareFacebook');
        const copyLinkBtn = document.getElementById('copyLink');

        // Confirmation Modal Elements
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmModalText = document.getElementById('confirmModalText');
        const confirmBtnYes = document.getElementById('confirmBtnYes');
        const confirmBtnNo = document.getElementById('confirmBtnNo');

        // Settings Modal Elements (now buttons on settings page)
        const logoutBtn = document.getElementById('logoutBtn');
        const shareProfileBtnSettings = document.getElementById('shareProfileBtn');
        const accountSettingsBtn = document.getElementById('accountSettingsBtn');
        const appSettingsBtn = document.getElementById('appSettingsBtn');
        const swavotiVerificationBtn = document.getElementById('swavotiVerificationBtn');
        // const moreSettingsBtn = document.getElementById('moreSettingsBtn'); // Original, now hidden
        const privacySettingsBtn = document.getElementById('privacySettingsBtn');

        // New buttons on Settings page
        const downloadDataBtn = document.getElementById('downloadDataBtn');
        const legalBtn = document.getElementById('legalBtn');
        // Support button is an <a> tag, no specific JS needed for its mailto action

        // Privacy Settings Page Elements (on the new dedicated page)
        const privacySettingsPage = document.getElementById('privacySettingsPage');
        const privacySettingsBackBtn = document.getElementById('privacySettingsBackBtn');
        // Selectors for dropdowns are already defined below, they will now refer to elements on the new page
        const privacyOnlineStatusSelect = document.getElementById('privacyOnlineStatus');
        const privacyStoryVisibilitySelect = document.getElementById('privacyStoryVisibility');
        const privacyCommentPermissionsSelect = document.getElementById('privacyCommentPermissions');
        const privacyAccountTypeSelect = document.getElementById('privacyAccountType');


        // Account Settings Modal Elements
        const accountSettingsModal = document.getElementById('accountSettingsModal');
        const closeAccountSettingsModal = document.getElementById('closeAccountSettingsModal');
        const accountSettingsAvatar = document.getElementById('accountSettingsAvatar');
        const accountSettingsName = document.getElementById('accountSettingsName');
        const accountSettingsEmail = document.getElementById('accountSettingsEmail');
        const accountSettingsBalance = document.getElementById('accountSettingsBalance');
        const resetPasswordBtn = document.getElementById('resetPasswordBtn');
        const changeEmailBtn = document.getElementById('changeEmailBtn');
        const onlineStatusToggle = document.getElementById('onlineStatusToggle');
        const readReceiptsToggle = document.getElementById('readReceiptsToggle');

        // App Settings Modal Elements
        const appSettingsModal = document.getElementById('appSettingsModal');
        const closeAppSettingsModal = document.getElementById('closeAppSettingsModal');

        // Verification Page Elements (replaces modal elements)
        const swavotiVerificationPage = document.getElementById('swavotiVerificationPage');
        const verificationStatusContainer = document.getElementById('verificationStatusContainer');
        const applyVerificationIframeModal = document.getElementById('applyVerificationIframeModal');
        const applyVerificationIframe = document.getElementById('applyVerificationIframe');
        const closeApplyVerificationIframe = document.getElementById('closeApplyVerificationIframe');
        const checkoutIframeContainer = document.getElementById('checkoutIframeContainer');
        const checkoutIframe = document.getElementById('checkoutIframe');
        // Old verification modal buttons (eligibilityCheck, proceedVerificationBtn, etc.) are removed conceptually
        // and will be dynamically created or handled by new functions.

        // Support Creator Modal Elements
        const supportCreatorModal = document.getElementById('supportCreatorModal');
        const closeSupportCreatorModal = document.getElementById('closeSupportCreatorModal');
        const supportPriceButtons = document.querySelectorAll('.support-price-btn');

        // Payment Modal Elements
        const paymentModal = document.getElementById('paymentModal');
        const closePaymentModal = document.getElementById('closePaymentModal');
        const paymentAmountDisplay = document.getElementById('paymentAmountDisplay');
        const payNowSupportBtn = document.getElementById('payNowSupportBtn');
        const paymentSupportError = document.getElementById('paymentSupportError');

        // Search Page Elements
        const searchInput = document.getElementById('searchInput');
        const searchFilterButtons = document.querySelectorAll('.search-filter-btn');
        const searchResultsContainer = document.getElementById('searchResultsContainer');

        // Reels Search Page Elements
        const reelsSearchInput = document.getElementById('reelsSearchInput');
        const reelsSearchResultsContainer = document.getElementById('reelsSearchResultsContainer');
        const reelsSearchBackBtn = document.getElementById('reelsSearchBackBtn');

        // Notification Search
        const notificationSearchInput = document.getElementById('notificationSearchInput');

        // Mentions Dropdown
        const mentionsDropdown = document.getElementById('mentionsDropdown');
        let currentMentionInputTarget = null;
        let mentionQueryDebounceTimer = null;


        // Message Filter Buttons
        const messageFilterButtons = document.querySelectorAll('.message-filter-btn');
        let currentMessageView = 'inbox'; // To track if viewing 'inbox' or 'groups'


        // App state
        let currentPostId = null;
        let currentProfileUserId = null;
        // let currentMediaFile = null; // Replaced by currentMediaFiles
        // let currentMediaType = null; // Replaced by currentMediaFiles
        let currentMediaFiles = []; // Array to hold multiple files for a post
        let isAddingMoreImages = false;
        let currentStoryId = null;
        let currentChatConversationId = null;
        let currentChatPartnerId = null;
        let currentTags = [];
        let currentEditProfileStep = 1;
        let newProfilePicFile = null;
        const userCache = {};
        let groupedStories = {};
        let currentViewingUserStories = [];
        let currentStoryIndex = 0;
        let currentSearchFilter = 'all';
        let currentMessageFilter = 'all';
        let searchDebounceTimer;
        let reelsSearchDebounceTimer;
        let typingTimeout;
        let editingMessageId = null;
        let isFirstTimeSetup = false;
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 750;
        let reelSwipeStartX = 0;
        let reelSwipeCurrentX = 0;
        let reelSwipeStartY = 0;
        let reelSwipeCurrentY = 0;
        const REEL_SWIPE_THRESHOLD = 75;


        // Lazy Loading Variables
        const POSTS_PER_BATCH = 3;
        const SKELETON_COUNT = 3;
        let lastVisibleHomePost = null;
        let lastVisibleExploreForYouPost = null;
        let lastVisibleExplorePopularPost = null;
        let lastVisibleExplorePopularReel = null;
        let lastVisibleReel = null;
        let homeFeedLoading = false;
        let exploreLoading = false;
        let reelsLoading = false;
        let homeFeedObserver = null;
        let exploreObserver = null;
        let reelsObserver = null;


        // Unsubscribe functions for real-time listeners
        let unsubscribeHomeFeed = null;
        let unsubscribeNotifications = null;
        let unsubscribeConversations = null;
        let unsubscribeProfileContent = null;
        let unsubscribeComments = null;
        let unsubscribeChatMessages = null;
        let unsubscribeChatPartnerStatus = null;
        let unsubscribeStories = null;
        let unsubscribeCurrentUserStatus = null;

        function unsubscribeAll() {
            if (unsubscribeHomeFeed) unsubscribeHomeFeed();
            if (unsubscribeNotifications) unsubscribeNotifications();
            if (unsubscribeConversations) unsubscribeConversations();
            if (unsubscribeProfileContent) unsubscribeProfileContent();
            if (unsubscribeComments) unsubscribeComments();
            if (unsubscribeChatMessages) unsubscribeChatMessages();
            if (unsubscribeChatPartnerStatus) unsubscribeChatPartnerStatus();
            if (unsubscribeStories) unsubscribeStories();
            if (unsubscribeCurrentUserStatus) unsubscribeCurrentUserStatus();

            lastVisibleHomePost = null;
            lastVisibleExploreForYouPost = null;
            lastVisibleExplorePopularPost = null;
            lastVisibleExplorePopularReel = null;
            lastVisibleReel = null;

            if (homeFeedObserver) homeFeedObserver.disconnect();
            if (exploreObserver) exploreObserver.disconnect();
            if (reelsObserver) reelsObserver.disconnect();
        }

        function showNotification(message, type = 'info') {
            const toast = document.getElementById('notificationToast');
            toast.textContent = message;
            toast.className = `notification-toast ${type}`;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function showConfirmation(message, onConfirm) {
            confirmModalText.textContent = message;
            confirmationModal.style.display = 'flex';

            confirmBtnYes.onclick = () => {
                confirmationModal.style.display = 'none';
                onConfirm();
            };

            confirmBtnNo.onclick = () => {
                confirmationModal.style.display = 'none';
            };
        }

        function showInlineLoader(container, type = 'post', count = 1) {
            if (!container) return;

            const isLikelyFreshLoad = !container.dataset.isLoadingMore && container.children.length > 0;
            if (isLikelyFreshLoad || container.children.length === 0) {
                 hideInlineLoader(container);
            }

            for (let i = 0; i < count; i++) {
                const skeletonWrapper = document.createElement('div');
                if (type === 'post') {
                    skeletonWrapper.className = 'skeleton-post-card'; // This is the container, doesn't need shimmer itself
                    skeletonWrapper.innerHTML = `
                        <div class="header">
                            <div class="skeleton-loader shimmer avatar"></div>
                            <div class="user-info">
                                <div class="skeleton-loader shimmer line"></div>
                                <div class="skeleton-loader shimmer line line-sm"></div>
                            </div>
                        </div>
                        <div class="skeleton-loader shimmer line"></div>
                        <div class="skeleton-loader shimmer line"></div>
                        <div class="skeleton-loader shimmer line" style="width: 80%;"></div>
                        <div class="skeleton-loader shimmer media"></div>
                        <div class="skeleton-loader shimmer actions"></div>
                    `;
                } else if (type === 'story') {
                    skeletonWrapper.className = 'skeleton-story-item-wrapper'; // Container
                    skeletonWrapper.innerHTML = `
                        <div class="skeleton-loader shimmer avatar"></div>
                        <div class="skeleton-loader shimmer line"></div>
                    `;
                } else if (type === 'reel-grid-item') {
                    // This one IS the loader itself, so add shimmer here
                    skeletonWrapper.className = 'skeleton-reel-grid-item-wrapper skeleton-loader shimmer';
                } else if (type === 'reel-item') {
                     skeletonWrapper.className = 'skeleton-reel-item-wrapper'; // Container
                     skeletonWrapper.innerHTML = `<div class="skeleton-loader shimmer media"></div>`;
                } else if (type === 'user-list-item') {
                    skeletonWrapper.className = 'skeleton-user-list-item'; // Container
                    skeletonWrapper.innerHTML = `
                        <div class="skeleton-loader shimmer avatar"></div>
                        <div class="text-lines">
                            <div class="skeleton-loader shimmer line-md"></div>
                            <div class="skeleton-loader shimmer line-sm"></div>
                        </div>
                    `;
                } else if (type === 'notification-item') {
                    skeletonWrapper.className = 'skeleton-notification-item'; // Container
                    skeletonWrapper.innerHTML = `
                        <div class="skeleton-loader shimmer avatar"></div>
                        <div class="text-lines">
                            <div class="skeleton-loader shimmer line-md" style="width: 80%;"></div>
                            <div class="skeleton-loader shimmer line-sm" style="width: 60%;"></div>
                            <div class="skeleton-loader shimmer line-xs"></div>
                        </div>
                    `;
                } else if (type === 'conversation-item') {
                    skeletonWrapper.className = 'skeleton-conversation-item'; // Container
                    skeletonWrapper.innerHTML = `
                        <div class="skeleton-loader shimmer avatar"></div>
                        <div class="text-lines">
                            <div class="skeleton-loader shimmer line-md"></div>
                            <div class="skeleton-loader shimmer line-sm"></div>
                        </div>
                        <div class="skeleton-loader shimmer time-placeholder"></div>
                    `;
                }
                container.appendChild(skeletonWrapper);
            }
        }

        function hideInlineLoader(container) {
            if (!container) return;
            const skeletons = container.querySelectorAll('.skeleton-post-card, .skeleton-story-item-wrapper, .skeleton-reel-grid-item-wrapper, .skeleton-reel-item-wrapper');
            skeletons.forEach(sk => sk.remove());
        }


        async function getUserData(userId) {
            if (userCache[userId]) {
                return userCache[userId];
            }
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = {...userDoc.data(), uid: userId};
                    userCache[userId] = userData;
                    return userData;
                }
                return null;
            } catch (error) {
                return null;
            }
        }

        // Old showLogin/showSignup listeners are removed as tabs handle this.
        // The small script for tab handling is already part of the new HTML.

        if (signupForm) { // Check if element exists before adding listener
            signupForm.addEventListener('submit', (e) => {
                e.preventDefault();

                const name = document.getElementById('new-signup-name').value;
                const username = document.getElementById('new-signup-username').value;
                const email = document.getElementById('new-signup-email').value;
                const password = document.getElementById('new-signup-password').value;
                const termsChecked = document.getElementById('termsCheck').checked;

                const signupButton = document.getElementById('newSignupBtn'); // Use new ID
                const originalButtonHTML = signupButton.innerHTML;

                signupError.textContent = ''; // Clear previous errors
                signupError.style.display = 'none';


                if (!termsChecked) {
                    signupError.textContent = 'You must agree to the Terms of Service and Privacy Policy.';
                    signupError.style.display = 'block';
                    return;
                }

                signupButton.disabled = true;
                signupButton.innerHTML = 'Processing... <div class="spinner"></div>';

                auth.createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        const user = userCredential.user;
                    return user.sendEmailVerification().then(() => {
                        return db.collection('users').doc(user.uid).set({
                            name: name,
                            username: username,
                            email: email,
                            profilePicUrl: `https://img.icons8.com/liquid-glass/48/user.png`,
                            title: '',
                            bio: '',
                            followers: [],
                            following: [],
                            hasActiveStory: false,
                            isProfileSetupComplete: false,
                            verified: false,
                            lastProfileEditTimestamp: null,
                            onlineStatus: true,
                            readReceipts: true,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }).then(() => {
                        showNotification('Account created! Please verify your email to log in.', 'success');
                        auth.signOut();
                        navigateToPage('login');
                    });
                })
                .catch((error) => {
                    signupError.textContent = error.message;
                    signupError.style.display = 'block';
                })
                .finally(() => {
                    // The termsCheck listener already handles enabling/disabling based on checkbox.
                    // We just need to restore HTML if it wasn't successful or reset for next attempt.
                    // If signup was successful, user is navigated away, so button state might not matter as much.
                    // However, if they stay on page due to error, restore it.
                    if (signupButton.disabled) { // Only restore if still disabled (e.g. error occurred)
                       signupButton.innerHTML = originalButtonHTML;
                       // Re-evaluate disabled state based on termsCheck, in case of error
                       signupButton.disabled = !document.getElementById('termsCheck').checked;
                    }
                });
            });
        }


        if (loginForm) { // Check if element exists
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();

                const email = document.getElementById('new-login-email').value;
                const password = document.getElementById('new-login-password').value;
                const loginButton = e.target.querySelector('.submit-btn'); // Targets the button within the submitted form
                const originalButtonHTML = loginButton.innerHTML;

                loginError.textContent = '';
                loginError.style.display = 'none';
                loginButton.disabled = true;
                loginButton.innerHTML = 'Logging In... <div class="spinner"></div>';

                auth.signInWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        const user = userCredential.user;
                        if (user.emailVerified) {
                            // Auth state change handles UI
                        } else {
                            auth.signOut();
                            loginError.textContent = 'Please verify your email address before logging in.';
                            loginError.style.display = 'block';
                            showNotification('Please verify your email address.', 'error');
                        }
                    })
                    .catch((error) => {
                        loginError.textContent = error.message;
                        loginError.style.display = 'block';
                    })
                    .finally(() => {
                        loginButton.disabled = false;
                        loginButton.innerHTML = originalButtonHTML;
                    });
            });
        }

        async function loadCurrentUserData() {
            const user = auth.currentUser;
            if (!user) return;

            const userData = await getUserData(user.uid);
            if (userData) {
                usernameDisplay.textContent = userData.username;
                document.getElementById('modal-profile-name').textContent = userData.name;

                const profileImg = document.querySelector('.user-profile img');
                profileImg.src = userData.profilePicUrl || `https://img.icons8.com/liquid-glass/48/user.png`;
                document.getElementById('modal-profile-img').src = profileImg.src;
                document.getElementById('comment-profile-img').src = profileImg.src;
            }
        }

        function getInitials(name) {
            if (!name) return 'U';
            return name.split(' ').map(part => part[0]).join('').toUpperCase();
        }

        async function loadHomeFeed(loadMore = false) {
            if (homeFeedLoading && loadMore) return;
            homeFeedLoading = true;
            homeFeed.dataset.isLoadingMore = loadMore.toString();


            if (!loadMore) {
                homeFeed.innerHTML = '';
                showInlineLoader(homeFeed, 'post', SKELETON_COUNT);
            }

            const currentUser = auth.currentUser;
            if (!currentUser) {
                hideInlineLoader(homeFeed);
                homeFeed.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Please log in to see your feed.</p>';
                homeFeedLoading = false;
                delete homeFeed.dataset.isLoadingMore;
                return;
            }

            const currentUserData = await getUserData(currentUser.uid);
            const followingIds = currentUserData.following || [];

            let query = db.collection('posts').orderBy('timestamp', 'desc').limit(POSTS_PER_BATCH);
            if (loadMore && lastVisibleHomePost) {
                query = query.startAfter(lastVisibleHomePost);
            }

            try {
                const querySnapshot = await query.get();

                if (!loadMore || querySnapshot.docs.length > 0) {
                    hideInlineLoader(homeFeed);
                }


                if (querySnapshot.empty) {
                    if (!loadMore && homeFeed.innerHTML.trim() === '') {
                        homeFeed.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Your feed is empty.</p>';
                    }
                    if (homeFeedObserver) homeFeedObserver.disconnect();
                    homeFeedLoading = false;
                    delete homeFeed.dataset.isLoadingMore;
                    return;
                }

                lastVisibleHomePost = querySnapshot.docs[querySnapshot.docs.length - 1];
            let postsAddedThisBatch = 0;
            // On initial load, keep track of total visible posts rendered so far for suggestion logic
            if (!loadMore) {
                if (typeof window.renderedVisiblePostsCount === 'undefined') {
                    window.renderedVisiblePostsCount = 0;
                }
                if(homeFeed.innerHTML.trim() === '' || homeFeed.querySelectorAll('.skeleton-post-card').length > 0 ) { // Reset if it's a true fresh load
                    window.renderedVisiblePostsCount = 0;
                    window.suggestionsRenderedThisLoad = false; // Flag to ensure only one suggestion box per initial load cycle
                }
            }

            // Determine if we can show suggestions based on the first batch size
            let potentialTotalPostsInFeed = querySnapshot.size; // For the current batch
            if (!loadMore) {
                // This is a rough estimate. A true total count would require another query.
                // For now, we'll use the size of the first fetched batch as an indicator.
                // If this first batch has > 9 items, we consider the condition met for this simplified version.
                window.canShowSuggestionsBasedOnCount = potentialTotalPostsInFeed > 9;
            }


                for (const doc of querySnapshot.docs) {
                    const postItem = { id: doc.id, data: doc.data() };
                    let isVisible = false;
                if (postItem.data.visibility === 'public' ||
                   (postItem.data.visibility === 'followers' && (postItem.data.userId === currentUser.uid || (currentUserData.following && currentUserData.following.includes(postItem.data.userId)))) ||
                   (postItem.data.visibility === 'private' && postItem.data.userId === currentUser.uid)) {
                    isVisible = true;
                }

                    if (isVisible) {
                        await renderPost(postItem.id, postItem.data, homeFeed);
                    postsAddedThisBatch++;
                    if (!loadMore) {
                        window.renderedVisiblePostsCount++;
                        // Insert suggested users section after the 7th visible post on initial load, if conditions met
                        if (window.renderedVisiblePostsCount === 7 &&
                            !window.suggestionsRenderedThisLoad &&
                            window.canShowSuggestionsBasedOnCount) {
                            await renderSuggestedUsersSection(homeFeed, currentUserData);
                            window.suggestionsRenderedThisLoad = true;
                        }
                    }
                    }
                }

            // If initial load had less than 7 posts but more than 0, and suggestions haven't been rendered yet,
            // and total count condition was met, render suggestions at the end of this first batch.
            // This handles cases where the first batch is small but still qualifies.
            if (!loadMore && window.renderedVisiblePostsCount > 0 && window.renderedVisiblePostsCount < 7 &&
                !window.suggestionsRenderedThisLoad && window.canShowSuggestionsBasedOnCount) {
                 await renderSuggestedUsersSection(homeFeed, currentUserData);
                 window.suggestionsRenderedThisLoad = true;
            }


            if (postsAddedThisBatch === 0 && !loadMore && homeFeed.innerHTML.trim() === '') {
                     homeFeed.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No visible posts.</p>';
                }

                if (querySnapshot.docs.length === POSTS_PER_BATCH) {
                    const lastPostElement = homeFeed.querySelector('.post-card:last-child');
                    if (lastPostElement) {
                        if (homeFeedObserver) homeFeedObserver.disconnect();
                        homeFeedObserver = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting && !homeFeedLoading) {
                                loadHomeFeed(true);
                            }
                        }, { threshold: 0.5 });
                        homeFeedObserver.observe(lastPostElement);
                    }
                } else {
                    if (homeFeedObserver) homeFeedObserver.disconnect();
                }

            } catch (error) {
                hideInlineLoader(homeFeed);
                homeFeed.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Could not load feed.</p>';
            } finally {
                homeFeedLoading = false;
                delete homeFeed.dataset.isLoadingMore;
            }
        }

        async function renderPost(postId, post, container) {
            const postElement = document.createElement('div');
            postElement.className = 'post-card';
            postElement.id = `post-${postId}`;

            const postTime = post.timestamp ? post.timestamp.toDate().toLocaleString() : 'Just now';
            const userData = await getUserData(post.userId);
            if (!userData) {
                return;
            }

            let mediaContent = '';
            if (post.mediaType === 'gallery' && post.mediaUrls && post.mediaUrls.length > 0) {
                const imagesHtml = post.mediaUrls.map(url => `<img src="${url}" class="post-gallery-image" alt="Post image">`).join('');
                mediaContent = `
                    <div class="post-gallery-container" id="gallery-${postId}">
                        <div class="post-gallery-inner">
                            ${imagesHtml}
                        </div>
                        <button class="gallery-nav prev" data-post-id="${postId}"><i class="fas fa-chevron-left"></i></button>
                        <button class="gallery-nav next" data-post-id="${postId}"><i class="fas fa-chevron-right"></i></button>
                        <div class="gallery-dots">
                            ${post.mediaUrls.map((_, index) => `<span class="dot ${index === 0 ? 'active' : ''}" data-index="${index}"></span>`).join('')}
                        </div>
                    </div>
                `;
            } else if (post.mediaUrl) { // Single image or video
                if (post.type === 'reel' && post.mediaType === 'video') { // For Reels embedded in feed
                    mediaContent = `
                        <div class="post-video-container">
                            <div class="media-loading-overlay"><div class="spinner"></div></div>
                            <video class="post-video" loop playsinline src="${post.mediaUrl}"></video>
                            <button class="video-mute-button" data-muted="false"><i class="fas fa-volume-up"></i></button>
                        </div>`;
                } else if (post.mediaType === 'video') { // For regular video posts
                    mediaContent = `
                        <div class="post-video-container">
                            <div class="media-loading-overlay"><div class="spinner"></div></div>
                            <video controls class="post-video"><source src="${post.mediaUrl}" type="video/mp4"></video>
                        </div>`;
                } else if (post.mediaType === 'image') {
                    mediaContent = `<img src="${post.mediaUrl}" class="post-image" alt="Post image">`;
                }
            }

            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            const isLiked = post.likes && currentUserId ? post.likes.includes(currentUserId) : false;

            const currentUserData = await getUserData(currentUserId);
            const isFollowing = currentUserData && currentUserData.following ? currentUserData.following.includes(post.userId) : false;

            const tagsHtml = (post.tags || []).map(tag => `<span class="tag-item">#${tag}</span>`).join('');

            const supportIconHtml = (post.monetized && post.userId !== currentUserId) ?
                                    `<i class="fas fa-hand-holding-usd support-icon" data-post-id="${postId}" data-creator-id="${post.userId}"></i>` : '';

            postElement.innerHTML = `
                <div class="post-header">
                    <div class="post-user" data-user-id="${post.userId}">
                        <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                        <div class="post-user-info">
                            <h4>
                                ${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}
                                ${post.userId !== currentUserId ? `<button class="follow-button ${isFollowing ? 'following' : ''}" data-user-id="${post.userId}">${isFollowing ? 'Following' : 'Follow'}</button>` : ''}
                                ${supportIconHtml}
                            </h4>
                            <p>${postTime} ${post.location ? ` ${post.location}` : ''}</p>
                        </div>
                    </div>
                    <div class="post-options">
                        <i class="fas fa-ellipsis-h"></i>
                        <div class="post-options-dropdown">
                            ${post.userId === currentUserId ?
                                `<button class="delete-post-btn" data-post-id="${postId}">Delete Post</button>` :
                                `<button class="report-post-btn" data-post-id="${postId}">Report Post</button>`
                            }
                        </div>
                    </div>
                </div>
                <div class="post-content">
                    <div class="post-text">${post.content || ''}</div>
                    ${mediaContent}
                    ${tagsHtml ? `<div class="tags-display">${tagsHtml}</div>` : ''}
                </div>
                <div class="post-stats">
                    <div class="post-likes">
                        <i class="fas fa-thumbs-up"></i> <span class="like-count">${post.likeCount || 0}</span>
                    </div>
                    <div class="post-comments">
                        ${post.commentCount || 0} comments
                    </div>
                </div>
                <div class="post-actions">
                    <div class="post-action like-btn ${isLiked ? 'liked' : ''}" data-post-id="${postId}">
                        <i class="far fa-thumbs-up"></i>
                        <span>Like</span>
                    </div>
                    <div class="post-action comment-btn" data-post-id="${postId}">
                        <i class="far fa-comment"></i>
                        <span>Comment</span>
                    </div>
                    <div class="post-action share-btn" data-post-id="${postId}">
                        <i class="fas fa-share"></i>
                        <span>Share</span>
                    </div>
                </div>
            `;

            container.appendChild(postElement);
            addPostEventListeners(postElement, postId, post.type === 'reel');

            // If the post is a reel and has a video container, manage its loading overlay
            if (post.type === 'reel' && post.mediaType === 'video') {
                const videoContainer = postElement.querySelector('.post-video-container');
                if (videoContainer) {
                    const overlay = videoContainer.querySelector('.media-loading-overlay');
                    if (overlay) {
                        hideOverlayAfterDelay(overlay, 6300); // 6.3 seconds
                    }
                }
            }
        }

        function renderVerificationPageLayout(status) {
            let statusBarHTML = '';
            // Generate status bar based on user's verification status
            switch (status) {
                case 'pending':
                    statusBarHTML = `<div class="verification-status-bar pending">Your application is pending review.</div>`;
                    break;
                case 'approved':
                    statusBarHTML = `<div class="verification-status-bar approved">You are a Swavoti Verified User!</div>`;
                    break;
                case 'rejected':
                    statusBarHTML = `<div class="verification-status-bar rejected">Your previous application was not approved. You may re-apply below.</div>`;
                    break;
            }

            const contentHTML = `
                ${statusBarHTML}
                <div class="verification-header">
                    <img src="https://thumbsnap.com/i/6UjxkZoq.jpg" alt="Swavoti Logo" class="verification-logo">
                    <div class="verification-title-group">
                        <h2>Swavoti</h2>
                        <i class="fas fa-check-circle verified-badge" style="font-size: 24px; margin-left: 8px;"></i>
                    </div>
                </div>

                <div class="verification-card">
                    <h3>What is Verification?</h3>
                    <p>Verification is a process that lets people in the Swavoti community know that an account of public interest is authentic. The verified badge appears next to the account name and on their profile.</p>
                </div>

                <div class="verification-card">
                    <h3>Why Get Verified?</h3>
                    <ul>
                        <li><i class="fas fa-check"></i> <strong>Authenticity:</strong> Confirms your identity to the community.</li>
                        <li><i class="fas fa-check"></i> <strong>Credibility:</strong> Builds trust with your followers and potential connections.</li>
                        <li><i class="fas fa-check"></i> <strong>Visibility:</strong> Verified accounts may receive prioritized visibility in search and discovery.</li>
                    </ul>
                </div>

                <div class="verification-card">
                    <h3>Who Can Apply?</h3>
                    <p>We verify accounts that are of public interest. This includes, but is not limited to:</p>
                    <ul>
                        <li><i class="fas fa-star"></i> Celebrities & Public Figures</li>
                        <li><i class="fas fa-briefcase"></i> Brands & Businesses</li>
                        <li><i class="fas fa-newspaper"></i> Journalists & Media Organizations</li>
                        <li><i class="fas fa-landmark"></i> Government Officials & Agencies</li>
                    </ul>
                </div>

                <div class="verification-card">
                    <h3>Requirements</h3>
                    <ul>
                        <li><strong>Complete Profile:</strong> Must have a bio and a profile picture.</li>
                        <li><strong>Active Usage:</strong> Your account must have been active within the last 30 days.</li>
                        <li><strong>Content:</strong> Must have at least 3 posts.</li>
                        <li><strong>Security:</strong> Secure your account with a confirmed email.</li>
                        <li><strong>Notability:</strong> Your account must represent a well-known, highly searched for person, brand, or entity.</li>
                        <li><strong>Proof of Identity:</strong> We may require a government-issued ID to confirm your identity.</li>
                    </ul>
                </div>

                <div class="verification-card">
                    <h3>How to Apply</h3>
                    <p>If you meet the requirements, you can apply for verification. The process involves filling out an application and potentially providing documentation.</p>
                    <button class="profile-btn primary-btn" id="applyForVerificationBtn" style="margin:15px auto 0 auto; display:block;">Apply Now</button>
                </div>

                <div class="verification-card">
                    <h3>Why Was I Rejected?</h3>
                    <p>Common reasons for rejection include an incomplete profile, insufficient notability, or not meeting our activity requirements. Ensure you meet all criteria before re-applying.</p>
                </div>

                <div class="verification-card faq">
                    <h3>Frequently Asked Questions</h3>
                    <p><strong>Q: Can I lose my verification badge?</strong></p>
                    <p>A: Yes. Verification can be removed at any time for violations of the Swavoti Terms of Service or if your account no longer meets our verification criteria.</p>
                </div>
            `;

            if(verificationStatusContainer) {
                verificationStatusContainer.innerHTML = contentHTML;
                addVerificationPageEventListeners();
            }
        }

        function addPostEventListeners(postElement, postId, isReelInFeed) {
            postElement.querySelector('.like-btn')?.addEventListener('click', () => toggleLike(postId, postElement.querySelector('.like-btn'), postElement.querySelector('.like-count')));
            postElement.querySelector('.comment-btn')?.addEventListener('click', () => showComments(postId));
            postElement.querySelector('.share-btn')?.addEventListener('click', () => openShareModal(postId, 'post'));
            postElement.querySelector('.post-user')?.addEventListener('click', (e) => {
                const userId = e.currentTarget.dataset.userId;
                navigateToPage('profile', userId);
            });
            postElement.querySelector('.follow-button')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const userId = e.currentTarget.dataset.userId;
                toggleFollow(userId, e.currentTarget);
            });
            const postOptionsIcon = postElement.querySelector('.post-options i.fa-ellipsis-h');
            postOptionsIcon?.addEventListener('click', (e) => {
                e.stopPropagation();
                openPostOptionsModal(postId);
            });

            // Gallery/Carousel Logic
            const galleryContainer = postElement.querySelector(`#gallery-${postId}`);
            if (galleryContainer) {
                const inner = galleryContainer.querySelector('.post-gallery-inner');
                const images = galleryContainer.querySelectorAll('.post-gallery-image');
                const prevBtn = galleryContainer.querySelector('.gallery-nav.prev');
                const nextBtn = galleryContainer.querySelector('.gallery-nav.next');
                const dotsContainer = galleryContainer.querySelector('.gallery-dots');
                let currentIndex = 0;
                const totalImages = images.length;

                function updateGalleryView() {
                    if (!inner || !dotsContainer) return;
                    inner.style.transform = `translateX(-${currentIndex * 100}%)`;

                    const currentDots = dotsContainer.querySelectorAll('.dot');
                    currentDots.forEach(dot => dot.classList.remove('active'));
                    if (currentDots[currentIndex]) {
                        currentDots[currentIndex].classList.add('active');
                    }
                    if(prevBtn) prevBtn.style.display = currentIndex === 0 ? 'none' : 'flex';
                    if(nextBtn) nextBtn.style.display = currentIndex === totalImages - 1 ? 'none' : 'flex';
                }

                if (totalImages <= 1) {
                    if(prevBtn) prevBtn.style.display = 'none';
                    if(nextBtn) nextBtn.style.display = 'none';
                    if(dotsContainer) dotsContainer.style.display = 'none';
                } else {
                     updateGalleryView();
                }

                prevBtn?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentIndex > 0) {
                        currentIndex--;
                        updateGalleryView();
                    }
                });

                nextBtn?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentIndex < totalImages - 1) {
                        currentIndex++;
                        updateGalleryView();
                    }
                });

                dotsContainer?.querySelectorAll('.dot').forEach(dot => {
                    dot.addEventListener('click', (e) => {
                        e.stopPropagation();
                        currentIndex = parseInt(e.target.dataset.index);
                        updateGalleryView();
                    });
                });
            }

            const supportIcon = postElement.querySelector('.support-icon');
            if (supportIcon) {
                supportIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const creatorId = e.currentTarget.dataset.creatorId;
                    openSupportCreatorModal(postId, creatorId);
                });
            }

            if (isReelInFeed) {
                const video = postElement.querySelector('.post-video');
                const muteButton = postElement.querySelector('.video-mute-button');

                if (video) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                video.play().catch(e => {});
                            } else {
                                video.pause();
                            }
                        });
                    }, { threshold: 0.5 });
                    observer.observe(video);

                    muteButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        video.muted = !video.muted;
                        muteButton.dataset.muted = video.muted;
                        muteButton.innerHTML = video.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
                    });
                }
            }
        }

        function deletePost(postId, postElement) {
            showConfirmation('Are you sure you want to delete this post?', async () => {
                try {
                    const commentsSnapshot = await db.collection('posts').doc(postId).collection('comments').get();
                    const batch = db.batch();
                    commentsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();

                    await db.collection('posts').doc(postId).delete();
                    postElement.remove();
                    showNotification('Post deleted successfully!', 'success');
                } catch (error) {
                    showNotification('Failed to delete post.', 'error');
                }
            });
        }

        function reportPost(postId) {
            showConfirmation('Are you sure you want to report this post?', async () => {
                const user = auth.currentUser;
                if (!user) {
                    showNotification('Please log in to report a post.', 'error');
                    return;
                }
                try {
                    await db.collection('reports').add({
                        postId: postId,
                        reporterUserId: user.uid,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        status: 'pending'
                    });
                    showNotification('Post reported. Our team will review it.', 'info');
                } catch (error) {
                    showNotification('Failed to report post.', 'error');
                }
            });
        }


        function toggleLike(id, likeBtnElement, likeCountElement, type = 'post', parentId = null) {
            const user = auth.currentUser;
            if (!user) return;

            let collectionRef;
            if (type === 'story') {
                collectionRef = db.collection('stories');
            } else if (type === 'comment' && parentId) {
                collectionRef = db.collection('posts').doc(parentId).collection('comments');
            } else {
                collectionRef = db.collection('posts');
            }

            const docRef = collectionRef.doc(id);

            db.runTransaction((transaction) => {
                return transaction.get(docRef).then((docSnapshot) => {
                    if (!docSnapshot.exists) throw "Document does not exist!";

                    const docData = docSnapshot.data();
                    const likes = docData.likes || [];
                    let likeCount = docData.likeCount || 0;

                    const likeIndex = likes.indexOf(user.uid);

                    if (likeIndex === -1) {
                        likes.push(user.uid);
                        likeCount++;
                        if (docData.userId && docData.userId !== user.uid) {
                            db.collection('notifications').add({
                                type: `${type}_like`,
                                senderUserId: user.uid,
                                recipientUserId: docData.userId,
                                postId: parentId || id,
                                commentId: type === 'comment' ? id : null,
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                read: false
                            });
                        }
                    } else {
                        likes.splice(likeIndex, 1);
                        likeCount = Math.max(0, likeCount - 1);
                    }

                    transaction.update(docRef, { likes: likes, likeCount: likeCount });

                    if (likeBtnElement) likeBtnElement.classList.toggle('liked', likes.includes(user.uid));
                    if (likeCountElement) likeCountElement.textContent = likeCount;
                });
            }).catch((error) => {
                showNotification("Couldn't update like.", "error");
            });
        }

        function showComments(postId) {
            currentPostId = postId;
            // const commentModal = document.getElementById('commentModal'); // Already global
            // const commentsList = document.getElementById('commentsList'); // Already global
            // Global variables commentModal and commentsList are used directly.
            commentsList.innerHTML = '<div class="loading-spinner-container"><div class="loader"></div></div>'; // Use new loader

            if (unsubscribeComments) unsubscribeComments();

            unsubscribeComments = db.collection('posts').doc(postId).collection('comments')
                .orderBy('timestamp', 'asc')
                .onSnapshot(async (querySnapshot) => {
                    commentsList.innerHTML = ''; // Clear loader
                    if (querySnapshot.empty) {
                        commentsList.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No comments yet.</p>';
                    } else {
                        for (const doc of querySnapshot.docs) {
                            await renderComment(doc.id, doc.data(), commentsList, postId);
                        }
                    }
                    commentsList.scrollTop = commentsList.scrollHeight;
                }, (error) => {
                    commentsList.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Could not load comments.</p>'; // Clear loader and show error
                });

            commentModal.style.display = 'flex';
        }

        async function renderComment(commentId, comment, container, postId) {
            const commentElement = document.createElement('div');
            commentElement.className = 'comment-item';
            commentElement.dataset.commentId = commentId;
            commentElement.dataset.postId = postId;
            commentElement.dataset.userId = comment.userId;

            const userData = await getUserData(comment.userId);
            if (!userData) return;

            const commentTime = comment.timestamp ? comment.timestamp.toDate().toLocaleTimeString() : '';

            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            const isLiked = comment.likes && currentUserId ? comment.likes.includes(currentUserId) : false;

            commentElement.innerHTML = `
                <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                <div class="comment-content-wrapper">
                    <strong>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</strong>
                    <p>${comment.text}</p>
                </div>
                <div class="comment-actions">
                    <span class="comment-time">${commentTime}</span>
                    <button class="comment-action-btn like-comment-btn ${isLiked ? 'liked' : ''}" data-comment-id="${commentId}" data-parent-id="${postId}">
                        Like (<span class="comment-like-count">${comment.likeCount || 0}</span>)
                    </button>
                    <button class="comment-action-btn reply-comment-btn" data-comment-id="${commentId}" data-username="${userData.username}">Reply</button>
                    ${comment.replyCount > 0 ? `<button class="comment-action-btn view-replies-btn" data-comment-id="${commentId}">View ${comment.replyCount} replies</button>` : ''}
                </div>
                <div class="replies-container" id="replies-${commentId}" style="display:none; margin-left: 45px; padding-top: 10px;">
                    <!-- Replies will be loaded here -->
                </div>
            `;

            container.appendChild(commentElement);

            const viewRepliesBtn = commentElement.querySelector('.view-replies-btn');
            if (viewRepliesBtn) {
                viewRepliesBtn.addEventListener('click', async (e) => {
                    const targetCommentId = e.currentTarget.dataset.commentId;
                    const repliesContainer = document.getElementById(`replies-${targetCommentId}`);
                    if (repliesContainer) {
                        const currentlyVisible = repliesContainer.style.display !== 'none';
                        repliesContainer.style.display = currentlyVisible ? 'none' : 'block';
                        viewRepliesBtn.textContent = currentlyVisible ? `View ${comment.replyCount} replies` : `Hide replies`;

                        if (!currentlyVisible && !repliesContainer.dataset.loaded) {
                            // Placeholder for fetching and rendering actual replies
                            repliesContainer.innerHTML = '<p style="font-size:12px; color:var(--gray-color);"><em>Loading replies... (placeholder)</em></p>';
                            // Simulate fetching replies
                            // In a real scenario, you'd query Firestore for replies to targetCommentId
                            // For now, just indicate they are loaded (simulated)
                            setTimeout(() => {
                                repliesContainer.innerHTML = '<p style="font-size:12px; color:var(--gray-color);"><em>Reply 1 (placeholder) <br> Reply 2 (placeholder)</em></p>';
                                repliesContainer.dataset.loaded = 'true';
                            }, 500);
                        }
                    }
                });
            }

            commentElement.querySelector('.like-comment-btn')?.addEventListener('click', (e) => {
                const commentIdToLike = e.currentTarget.dataset.commentId;
                const parentPostId = e.currentTarget.dataset.parentId;
                const likeBtn = e.currentTarget;
                const likeCountSpan = e.currentTarget.querySelector('.comment-like-count');
                toggleLike(commentIdToLike, likeBtn, likeCountSpan, 'comment', parentPostId);
            });

            commentElement.querySelector('.reply-comment-btn')?.addEventListener('click', (e) => {
                const usernameToReply = e.currentTarget.dataset.username;
                document.getElementById('commentText').value = `@${usernameToReply} `;
                document.getElementById('commentText').focus();
            });

            if (comment.userId === currentUserId) {
                let pressTimer = null;
                let touchStartX = 0;
                let touchStartY = 0;
                const MAX_TOUCH_MOVE = 10;

                const clearPressTimer = () => {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                        pressTimer = null;
                    }
                };

                const handleLongPressAction = () => {
                    showConfirmation('Do you want to delete this comment?', () => {
                        deleteComment(commentId, postId);
                    });
                };

                const startPress = (e) => {
                    if (e.target.closest('button.comment-action-btn')) return;

                    if (e.type === 'touchstart') {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                    clearPressTimer();
                    pressTimer = setTimeout(handleLongPressAction, LONG_PRESS_DURATION);
                };

                const cancelPress = (e) => {
                    if (e.type === 'touchmove') {
                        if (Math.abs(e.touches[0].clientX - touchStartX) > MAX_TOUCH_MOVE ||
                            Math.abs(e.touches[0].clientY - touchStartY) > MAX_TOUCH_MOVE) {
                            clearPressTimer();
                        }
                    } else {
                        clearPressTimer();
                    }
                };

                commentElement.addEventListener('mousedown', startPress);
                commentElement.addEventListener('touchstart', startPress, { passive: true });

                commentElement.addEventListener('mouseup', cancelPress);
                commentElement.addEventListener('mouseleave', cancelPress);
                commentElement.addEventListener('touchend', cancelPress);
                commentElement.addEventListener('touchcancel', cancelPress);
                commentElement.addEventListener('touchmove', cancelPress, { passive: true });
            }
        }

        async function deleteComment(commentId, postId) {
            if (!commentId || !postId) {
                showNotification('Error: Comment or Post ID missing.', 'error');
                return;
            }
            try {
                await db.collection('posts').doc(postId).collection('comments').doc(commentId).delete();
                await db.collection('posts').doc(postId).update({
                    commentCount: firebase.firestore.FieldValue.increment(-1)
                });
                showNotification('Comment deleted successfully!', 'success');
            } catch (error) {
                showNotification('Failed to delete comment.', 'error');
            }
        }


        document.getElementById('commentForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const user = auth.currentUser;
            if (!user || !currentPostId) return;

            const commentText = document.getElementById('commentText').value;
            if (!commentText.trim()) return;

            db.collection('posts').doc(currentPostId).collection('comments').add({
                userId: user.uid,
                text: commentText,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                likes: [],
                likeCount: 0
            }).then(() => {
                return db.collection('posts').doc(currentPostId).update({
                    commentCount: firebase.firestore.FieldValue.increment(1)
                });
            }).then(() => {
                document.getElementById('commentText').value = '';
            }).catch(error => {
                showNotification("Could not post comment.", "error");
            });
        });

        document.getElementById('closeCommentModal').addEventListener('click', () => {
            document.getElementById('commentModal').style.display = 'none';
            if (unsubscribeComments) unsubscribeComments();
        });

        function loadNotifications() {
            const user = auth.currentUser;
            if (!user) return;

            notificationsList.innerHTML = '';
            showInlineLoader(notificationsList, 'notification-item', SKELETON_COUNT);
            if (unsubscribeNotifications) unsubscribeNotifications();

            unsubscribeNotifications = db.collection('notifications')
                .where('recipientUserId', '==', user.uid)
                .orderBy('timestamp', 'desc')
                .onSnapshot(async (querySnapshot) => {
                    hideInlineLoader(notificationsList);
                    notificationsList.innerHTML = '';
                    let unreadCount = 0;

                    if (querySnapshot.empty) {
                        notificationsList.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No notifications yet.</p>';
                    } else {
                        for (const doc of querySnapshot.docs) {
                            const notification = doc.data();
                            if (!notification.read) unreadCount++;
                            await renderNotification(doc.id, notification);
                        }
                    }
                    notificationCount.textContent = unreadCount;
                }, (error) => {
                    hideInlineLoader(notificationsList);
                    notificationsList.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Could not load notifications.</p>';
                });
        }

        async function renderNotification(notificationId, notification) {
            const notificationElement = document.createElement('div');
            notificationElement.className = `notification-item ${notification.read ? '' : 'notification-unread'}`;

            const userData = await getUserData(notification.senderUserId);
            if (!userData) return;

            notificationElement.innerHTML = `
                <a href="#profile/${notification.senderUserId}" class="notification-avatar-link">
                    <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                </a>
                <div class="notification-content">
                    <p><strong>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</strong> ${getNotificationText(notification)}</p>
                    <small class="notification-time">${notification.timestamp.toDate().toLocaleString()}</small>
                    ${notification.type === 'follow' ? `<button class="follow-back-btn profile-btn secondary-btn" data-user-id="${notification.senderUserId}" style="padding: 4px 8px; font-size: 12px; margin-top: 5px;">Follow Back</button>` : ''}
                </div>
                <div class="post-options" style="margin-left: auto;">
                    <i class="fas fa-ellipsis-h" data-notification-id="${notificationId}"></i>
                </div>
            `;

            notificationElement.querySelector('.follow-back-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFollow(e.target.dataset.userId, e.target);
            });

            notificationElement.addEventListener('click', (e) => {
                if (e.target.classList.contains('fa-ellipsis-h') || e.target.closest('.follow-back-btn')) {
                    e.stopPropagation();
                    if(e.target.classList.contains('fa-ellipsis-h')) {
                       openNotificationOptionsModal(e.target.dataset.notificationId);
                    }
                    return;
                }
                if (!notification.read) {
                    db.collection('notifications').doc(notificationId).update({ read: true });
                }
                handleNotificationClick(notification);
            });

            notificationsList.appendChild(notificationElement);
        }

        function getNotificationText(notification) {
            switch (notification.type) {
                case 'like': return 'liked your post.';
                case 'comment': return 'commented on your post.';
                case 'follow': return 'started following you.';
                case 'story_like': return 'liked your story.';
                case 'story_reply': return `replied to your story: "${notification.replyText}"`;
                case 'comment_like': return 'liked your comment.';
                case 'post_like': return 'liked your post.'; // More specific
                case 'reel_like': return 'liked your reel.'; // More specific
                default: return 'sent you a notification.';
            }
        }

        function handleNotificationClick(notification) {
            switch (notification.type) {
                case 'like':
                case 'comment':
                case 'comment_like':
                    navigateToPage('home');
                    break;
                case 'follow':
                    navigateToPage('profile', notification.senderUserId);
                    break;
                case 'story_like':
                case 'story_reply':
                    navigateToPage('explore');
                    break;
                default:
                    navigateToPage('home');
            }
        }

        async function loadConversations() {
            const user = auth.currentUser;
            if (!user) return;

            // Wire up header buttons since this function is called when the page is active
            document.getElementById('messagesSettingsBtn')?.addEventListener('click', () => navigateToPage('manageMedia'));
            document.getElementById('newGroupBtn')?.addEventListener('click', openNewGroupModal);

            // Load stories for the messages page - REMOVED
            // const messagePageStoriesContainer = document.getElementById('messagePageStories');
            // if (messagePageStoriesContainer) {
            //     loadStories(messagePageStoriesContainer); // Assuming loadStories can handle different containers
            // }

            conversationsList.innerHTML = '<div class="loading-spinner-container"><div class="loader"></div></div>'; // Use new grid/dot loader

            if (unsubscribeConversations) unsubscribeConversations();

            const userData = await getUserData(user.uid);
            const following = userData.following || []; // Needed for 'following' filter if re-enabled

            if (unsubscribeConversations) unsubscribeConversations();
            conversationsList.innerHTML = '<div class="loading-spinner-container"><div class="loader"></div></div>';
            let unreadOverallCount = 0; // For the badge

            if (currentMessageView === 'inbox') {
                document.querySelector('.message-section-title').textContent = 'Inbox';
                let inboxQuery = db.collection('conversations')
                    .where('participants', 'array-contains', user.uid)
                    // Add a filter to distinguish between DMs and group chats if groups also use 'conversations'
                    // For now, assuming 'conversations' are DMs. If groups are also in 'conversations',
                    // you'll need a 'type' field (e.g., 'dm' vs 'group') in your conversation documents.
                    // .where('type', '==', 'dm') // Example if you add a type field
                    .orderBy('lastMessage.timestamp', 'desc');

                unsubscribeConversations = inboxQuery.onSnapshot(async (querySnapshot) => {
                    conversationsList.innerHTML = '';
                    const dmConversations = [];
                    let unreadInboxCount = 0;

                    for (const doc of querySnapshot.docs) {
                        const conversation = doc.data();
                        // Ensure it's a DM (e.g. by checking participants length or a type field)
                        if (conversation.participants.length === 2) { // Simple check for DMs
                            dmConversations.push({ id: doc.id, data: conversation });
                            if (conversation.lastMessage && !conversation.lastMessage.read && conversation.lastMessage.senderId !== user.uid) {
                                unreadInboxCount++;
                                unreadOverallCount++;
                            }
                        }
                    }

                    messageCount.textContent = unreadOverallCount; // Update global unread count

                    if (dmConversations.length === 0) {
                        conversationsList.innerHTML = '<p style="text-align:center;color:var(--gray-color);">Your inbox is empty.</p>';
                    } else {
                        for (const convItem of dmConversations) {
                            await renderConversation(convItem.id, convItem.data);
                        }
                    }
                }, (error) => {
                    console.error("Error loading inbox:", error);
                    conversationsList.innerHTML = '<p style="text-align:center;color:var(--danger-color);">Could not load inbox.</p>';
                });

            } else if (currentMessageView === 'groups') {
                document.querySelector('.message-section-title').textContent = 'Groups';
                let groupsQuery = db.collection('groups')
                    .where('members', 'array-contains', user.uid)
                    .orderBy('lastMessage.timestamp', 'desc'); // Assuming groups also have lastMessage

                unsubscribeConversations = groupsQuery.onSnapshot(async (querySnapshot) => {
                    conversationsList.innerHTML = '';
                     let unreadGroupCount = 0;

                    if (querySnapshot.empty) {
                        conversationsList.innerHTML = '<p style="text-align:center;color:var(--gray-color);">You are not part of any groups yet.</p>';
                    } else {
                        for (const doc of querySnapshot.docs) {
                            // Note: Group messages might be stored differently (e.g., subcollection in group doc)
                            // This assumes group doc itself has `lastMessage` for listing purposes.
                            // Actual chat messages for groups would need a separate `openGroupConversation` logic.
                            await renderGroupConversationItem(doc.id, doc.data());
                             if (doc.data().lastMessage && !doc.data().lastMessage.readBy?.includes(user.uid) && doc.data().lastMessage.senderId !== user.uid) {
                                unreadGroupCount++;
                                unreadOverallCount++;
                            }
                        }
                    }
                     messageCount.textContent = unreadOverallCount; // Update global unread count

                }, (error) => {
                    console.error("Error loading groups:", error);
                    conversationsList.innerHTML = '<p style="text-align:center;color:var(--danger-color);">Could not load groups.</p>';
                });
            }
        }

        async function renderGroupConversationItem(groupId, groupData) {
            const groupElement = document.createElement('div');
            groupElement.className = 'message-item'; // Can reuse style or create specific group-item style

            const lastMessage = groupData.lastMessage || {};
            // Unread logic for groups needs to check if current user is in `readBy` array
            const isUnread = lastMessage && lastMessage.senderId !== auth.currentUser.uid && (!lastMessage.readBy || !lastMessage.readBy.includes(auth.currentUser.uid));

            groupElement.innerHTML = `
                <img src="${groupData.iconUrl || 'https://placehold.co/50x50/cccccc/333333?text=G'}" alt="${groupData.name}" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 15px;">
                <div class="message-content">
                    <h4>${groupData.name} ${groupData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</h4>
                    <p class="message-preview ${isUnread ? 'message-unread' : ''}">${lastMessage.senderUsername ? lastMessage.senderUsername + ': ' : ''}${lastMessage.text || 'No messages yet'}</p>
                </div>
                <div class="message-time">${lastMessage.timestamp ? lastMessage.timestamp.toDate().toLocaleTimeString() : ''}</div>
            `;

            groupElement.addEventListener('click', () => {
                // TODO: Implement openGroupConversation(groupId) - this will be different from DMs
                showNotification(`Opening group "${groupData.name}" (Chat UI not yet implemented for groups).`, "info");
                // For now, this is a placeholder. You'll need a new chat modal/UI for group chats.
                // It would be similar to `openConversation` but would fetch messages from the group's message subcollection
                // and handle multiple participants in the UI.
            });
            conversationsList.appendChild(groupElement);
        }

        async function renderConversation(conversationId, conversation, otherUserData = null) {
            const conversationElement = document.createElement('div');
            conversationElement.className = 'message-item';

            const otherParticipantId = conversation.participants.find(id => id !== auth.currentUser.uid);
            // If otherUserData is not passed (e.g. when loading initial list), fetch it.
            const userData = otherUserData || await getUserData(otherParticipantId);
            if (!userData) return;

            const lastMessage = conversation.lastMessage || {};
            const isUnread = lastMessage && !lastMessage.read && lastMessage.senderId !== auth.currentUser.uid;

            conversationElement.innerHTML = `
                <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                <div class="message-content">
                    <h4>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</h4>
                    <p class="message-preview ${isUnread ? 'message-unread' : ''}">${lastMessage.text || 'No messages yet'}</p>
                </div>
                <div class="message-time">${lastMessage.timestamp ? lastMessage.timestamp.toDate().toLocaleTimeString() : ''}</div>
            `;

            conversationElement.addEventListener('click', () => openConversation(conversationId, otherParticipantId));
            conversationsList.appendChild(conversationElement);
        }

        messageFilterButtons.forEach(button => {
            button.addEventListener('click', () => {
                messageFilterButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentMessageView = button.dataset.messageFilter; // 'inbox' or 'groups'
                loadConversations(); // This will now use currentMessageView
            });
        });


        async function startNewConversation(targetUserId) {
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            const participants = [currentUser.uid, targetUserId].sort();
            const conversationQuery = await db.collection('conversations')
                .where('participants', '==', participants)
                .limit(1)
                .get();

            if (!conversationQuery.empty) {
                openConversation(conversationQuery.docs[0].id, targetUserId);
            } else {
                const newConversationRef = await db.collection('conversations').add({
                    participants: participants,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: {
                        text: 'Conversation started',
                        senderId: currentUser.uid,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: true
                    },
                    typingStatus: {}
                });
                openConversation(newConversationRef.id, targetUserId);
            }
        }

        async function openConversation(conversationId, chatPartnerUid) {
            currentChatConversationId = conversationId;
            currentChatPartnerId = chatPartnerUid;

            const chatPartnerData = await getUserData(chatPartnerUid);
            if (chatPartnerData) {
                chatPartnerName.innerHTML = `${chatPartnerData.name} ${chatPartnerData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}`;
                chatPartnerAvatar.src = chatPartnerData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png';
            }

            chatMessages.innerHTML = '';
            showInlineLoader(chatMessages, 'post', 1);
            chatModal.style.display = 'flex';
            bottomNav.style.display = 'none';

            if (unsubscribeChatMessages) unsubscribeChatMessages();
            if (unsubscribeChatPartnerStatus) unsubscribeChatPartnerStatus();

            unsubscribeChatMessages = db.collection('conversations').doc(conversationId).collection('messages')
                .orderBy('timestamp', 'asc')
                .onSnapshot((querySnapshot) => {
                    hideInlineLoader(chatMessages);
                    chatMessages.innerHTML = '';
                    if (querySnapshot.empty) {
                        chatMessages.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Say hello!</p>';
                    } else {
                        querySnapshot.forEach((doc) => renderMessage(doc.id, doc.data()));
                    }
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, (error) => {
                    hideInlineLoader(chatMessages);
                    chatMessages.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Could not load messages.</p>';
                });

            unsubscribeChatPartnerStatus = db.collection('conversations').doc(conversationId)
                .onSnapshot(async (docSnapshot) => {
                    if (docSnapshot.exists) {
                        const conversationData = docSnapshot.data();
                        const typingStatus = conversationData.typingStatus || {};
                        const partnerIsTyping = typingStatus[chatPartnerUid] === true;

                        chatTypingIndicator.style.display = partnerIsTyping ? 'inline' : 'none';
                        chatPartnerOnlineStatus.style.display = partnerIsTyping ? 'none' : 'inline';

                        const partnerUserData = await getUserData(chatPartnerUid);
                        if (partnerUserData) {
                            chatPartnerOnlineStatus.textContent = partnerUserData.onlineStatus ? 'Online' : 'Offline';
                            chatPartnerOnlineStatus.classList.toggle('online', partnerUserData.onlineStatus);
                        } else {
                            chatPartnerOnlineStatus.textContent = '';
                        }
                    }
                }, (error) => {});
        }

        function renderMessage(messageId, message) {
            const messageElement = document.createElement('div');
            messageElement.className = `message-bubble ${message.senderId === auth.currentUser.uid ? 'sent' : 'received'}`;
            messageElement.dataset.messageId = messageId;

            let contentHtml = message.text || '';
            if (message.mediaType === 'image' && message.mediaUrl) {
                contentHtml += `<img src="${message.mediaUrl}" style="max-width: 100%; border-radius: 8px; margin-top: 5px;">`;
            }

            const messageTime = message.timestamp
                                ? (message.timestamp.toDate ? message.timestamp.toDate().toLocaleTimeString() : new Date(message.timestamp).toLocaleTimeString())
                                : '';

            messageElement.innerHTML = `
                ${contentHtml}
                <span class="timestamp">${messageTime}</span>
                ${message.senderId === auth.currentUser.uid ? `
                    <div class="chat-message-options">
                        <i class="fas fa-ellipsis-h"></i>
                        <div class="chat-message-options-dropdown">
                            <button class="edit-message-btn" data-message-id="${messageId}" data-message-text="${message.text || ''}">Edit</button>
                            <button class="delete-message-btn" data-message-id="${messageId}">Delete</button>
                        </div>
                    </div>
                ` : ''}
            `;
            chatMessages.appendChild(messageElement);

            const optionsIcon = messageElement.querySelector('.chat-message-options i');
            const optionsDropdown = messageElement.querySelector('.chat-message-options-dropdown');
            if (optionsIcon && optionsDropdown) {
                optionsIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    optionsDropdown.style.display = optionsDropdown.style.display === 'block' ? 'none' : 'block';
                });
                document.addEventListener('click', (e) => {
                    if (!optionsDropdown.contains(e.target) && e.target !== optionsIcon) {
                        optionsDropdown.style.display = 'none';
                    }
                });
            }

            messageElement.querySelector('.edit-message-btn')?.addEventListener('click', (e) => {
                const msgId = e.currentTarget.dataset.messageId;
                const msgText = e.currentTarget.dataset.messageText;
                editMessage(msgId, msgText);
                optionsDropdown.style.display = 'none';
            });
            messageElement.querySelector('.delete-message-btn')?.addEventListener('click', (e) => {
                const msgId = e.currentTarget.dataset.messageId;
                deleteMessage(msgId);
                optionsDropdown.style.display = 'none';
            });
        }

        function clearChatMediaPreview() {
            chatMediaPreviewContainer.style.display = 'none';
            chatImagePreview.style.display = 'none';
            chatImagePreview.src = '';
            currentChatMediaFile = null;
            currentChatMediaType = null;
            removeChatMediaPreview.style.display = 'none';
        }

        chatImageUploadBtn.addEventListener('click', () => chatImageInput.click());
        chatImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.match('image.*')) return;

            currentChatMediaFile = file;
            currentChatMediaType = 'image';

            const reader = new FileReader();
            reader.onload = (event) => {
                chatImagePreview.src = event.target.result;
                chatImagePreview.style.display = 'block';
                chatMediaPreviewContainer.style.display = 'flex';
                removeChatMediaPreview.style.display = 'block';
            };
            reader.readAsDataURL(file);
        });

        removeChatMediaPreview.addEventListener('click', clearChatMediaPreview);

        let typingTimer;
        const TYPING_TIMEOUT_MS = 2000;

        async function setTypingStatus(isTyping) {
            const user = auth.currentUser;
            if (!user || !currentChatConversationId) return;

            try {
                await db.collection('conversations').doc(currentChatConversationId).update({
                    [`typingStatus.${user.uid}`]: isTyping
                });
            } catch (error) {}
        }

        chatMessageInput.addEventListener('input', () => {
            if (auth.currentUser && currentChatConversationId) {
                setTypingStatus(true);
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => {
                    setTypingStatus(false);
                }, TYPING_TIMEOUT_MS);
            }
        });


        chatInputForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const user = auth.currentUser;
            if (!user || !currentChatConversationId) return;

            const messageText = chatMessageInput.value.trim();

            if (!messageText && !currentChatMediaFile && !editingMessageId) {
                showNotification("Message cannot be empty.", "info");
                return;
            }

            let mediaUrl = null;
            if (currentChatMediaFile) {
                try {
                    renderMessage('temp-id-' + Date.now(), {
                        senderId: user.uid,
                        text: 'Sending media...',
                        timestamp: new Date(),
                        mediaType: currentChatMediaType,
                        mediaUrl: currentChatMediaType === 'image' ? URL.createObjectURL(currentChatMediaFile) : null
                    });
                    chatMessages.scrollTop = chatMessages.scrollHeight;

                    mediaUrl = await uploadFile(currentChatMediaFile);
                } catch (error) {
                    showNotification("Failed to upload media.", "error");
                    clearChatMediaPreview();
                    return;
                }
            }

            const messageData = {
                senderId: user.uid,
                text: messageText,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                read: false,
                ...(mediaUrl && { mediaUrl: mediaUrl, mediaType: currentChatMediaType })
            };

            try {
                if (editingMessageId) {
                    await db.collection('conversations').doc(currentChatConversationId).collection('messages').doc(editingMessageId).update({
                        text: messageText,
                        editedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showNotification("Message updated!", "success");
                    editingMessageId = null;
                    chatSendButton.textContent = 'Send';
                } else {
                    await db.collection('conversations').doc(currentChatConversationId).collection('messages').add(messageData);
                    await db.collection('conversations').doc(currentChatConversationId).update({ lastMessage: messageData });
                    showNotification("Message sent!", "success");
                }
                chatMessageInput.value = '';
                clearChatMediaPreview();
                setTypingStatus(false);
            } catch (error) {
                showNotification("Message could not be sent/edited.", "error");
            }
        });

        function deleteMessage(messageId) {
            showConfirmation('Are you sure you want to delete this message?', async () => {
                try {
                    await db.collection('conversations').doc(currentChatConversationId).collection('messages').doc(messageId).delete();
                    showNotification('Message deleted.', 'success');
                } catch (error) {
                    showNotification('Failed to delete message.', 'error');
                }
            });
        }

        function editMessage(messageId, currentText) {
            editingMessageId = messageId;
            chatMessageInput.value = currentText;
            chatSendButton.textContent = 'Save';
            chatMessageInput.focus();
        }


        closeChatModal.addEventListener('click', () => {
            chatModal.style.display = 'none';
            if (unsubscribeChatMessages) unsubscribeChatMessages();
            if (unsubscribeChatPartnerStatus) unsubscribeChatPartnerStatus();
            currentChatConversationId = null;
            currentChatPartnerId = null;
        // bottomNav.style.display = 'flex'; // Problematic line - Replaced by handleHashChange or explicit check
            clearChatMediaPreview();
            setTypingStatus(false);
            editingMessageId = null;
            chatSendButton.textContent = 'Send';
        });


        async function loadProfileContent(userId, tab = 'posts') {
            currentProfileUserId = userId;
            profileContent.innerHTML = '';

            const isOwnProfile = auth.currentUser && auth.currentUser.uid === userId;
            const userData = await getUserData(userId);
            if (!userData) {
                hideInlineLoader(profileContent);
                profileContent.innerHTML = "<p style='text-align:center;color:var(--gray-color);padding:20px;'>User not found.</p>";
                return;
            }

            profileName.innerHTML = `${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}`;
            profileTitle.textContent = userData.title || '';
            profileBio.textContent = userData.bio || '';
            profileAvatar.src = userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png';
            followerCount.textContent = userData.followers ? userData.followers.length : 0;
            followingCount.textContent = userData.following ? userData.following.length : 0;

            document.querySelector('.profile-stat:nth-child(2) .stat-number').onclick = () => navigateToPage('followers', userId);
            document.querySelector('.profile-stat:nth-child(2) .stat-label').onclick = () => navigateToPage('followers', userId);
            document.querySelector('.profile-stat:nth-child(3) .stat-number').onclick = () => navigateToPage('following', userId);
            document.querySelector('.profile-stat:nth-child(3) .stat-label').onclick = () => navigateToPage('following', userId);

            if (isOwnProfile) {
                profileActions.innerHTML = `
                    <button class="profile-btn primary-btn" id="editProfileBtn">Edit Profile</button>
                    <button class="profile-btn secondary-btn" id="settingsProfileBtn">Settings</button>
                `;
                document.getElementById('editProfileBtn').addEventListener('click', () => openEditProfileModal(false));
                document.getElementById('settingsProfileBtn').addEventListener('click', () => navigateToPage('settings'));
            } else {
                const currentUserData = await getUserData(auth.currentUser.uid);
                const isFollowing = currentUserData.following && currentUserData.following.includes(userId);
                profileActions.innerHTML = `
                    <button class="profile-btn ${isFollowing ? 'secondary-btn' : 'primary-btn'}" id="followBtn">${isFollowing ? 'Following' : 'Follow'}</button>
                    <button class="profile-btn secondary-btn" id="messageProfileBtn">Message</button>
                    <button class="profile-btn secondary-btn" id="shareProfileBtnOtherUser"><i class="fas fa-share-alt"></i> Share</button>
                `;
                document.getElementById('followBtn').addEventListener('click', () => toggleFollow(userId, document.getElementById('followBtn')));
                document.getElementById('messageProfileBtn').addEventListener('click', () => startNewConversation(userId));
                document.getElementById('shareProfileBtnOtherUser').addEventListener('click', () => openShareModal(userId, 'profile'));
            }

            if (unsubscribeProfileContent) unsubscribeProfileContent();

            let query;
            let skeletonType = 'post';
            let skeletonContainer = profileContent;
            let skeletonCount = SKELETON_COUNT;

            if (tab === 'posts') {
                query = db.collection('posts')
                    .where('userId', '==', userId)
                    .where('type', '==', 'post');
                skeletonType = 'post';
            } else if (tab === 'reels') {
                query = db.collection('posts')
                    .where('userId', '==', userId)
                    .where('type', '==', 'reel');
                skeletonType = 'reel-grid-item';
                profileContent.innerHTML = '<div class="profile-grid"></div>';
                skeletonContainer = profileContent.querySelector('.profile-grid');
                skeletonCount = 6;
            } else {
                profileContent.innerHTML = '<p style="text-align:center;padding:20px;color:var(--gray-color)">Saved posts feature coming soon!</p>';
                return;
            }

            showInlineLoader(skeletonContainer, skeletonType, skeletonCount);

            unsubscribeProfileContent = query.orderBy('timestamp', 'desc')
                .onSnapshot(async (querySnapshot) => {
                    hideInlineLoader(skeletonContainer);
                    if (tab === 'reels') {
                        if (!skeletonContainer.classList.contains('profile-grid')) {
                             skeletonContainer.innerHTML = '<div class="profile-grid"></div>';
                             skeletonContainer = skeletonContainer.querySelector('.profile-grid');
                        } else {
                            skeletonContainer.innerHTML = '';
                        }
                    } else {
                         skeletonContainer.innerHTML = '';
                    }

                    postCount.textContent = querySnapshot.size;

                    if (querySnapshot.empty) {
                        skeletonContainer.innerHTML = `<p style="text-align:center;color:var(--gray-color);padding:20px;">No ${tab} yet.</p>`;
                        return;
                    }

                    if (tab === 'reels') {
                        querySnapshot.docs.forEach(doc => renderReelThumbnail(doc.id, doc.data(), skeletonContainer));
                    } else {
                        for (const doc of querySnapshot.docs) {
                            await renderPost(doc.id, doc.data(), skeletonContainer);
                        }
                    }
                }, error => {
                    hideInlineLoader(skeletonContainer);
                    skeletonContainer.innerHTML = `<p class="text-center text-red-500 p-4">Could not load ${tab}.</p>`;
                });
        }

        function renderReelThumbnail(reelId, reelData, container) {
            const item = document.createElement('div');
            item.className = 'profile-grid-item';
            // Ensure the video tag has the 'muted' attribute
            item.innerHTML = `<video src="${reelData.mediaUrl}" muted playsinline loop preload="metadata"></video>`;
            item.addEventListener('click', () => {
                // When opening the full reels viewer, we might want to pass the specific reelId
                // to start with that reel, and it should play with sound.
                // For now, showReels() opens the general reels viewer.
                // The `muted` attribute here is for the thumbnail grid view only.
                showReels(reelId);
            });
            container.appendChild(item);
        }

        async function loadFollowersPage(userId) {
            followersListContainer.innerHTML = '';
            showInlineLoader(followersListContainer, 'user-list-item', 3);

            const userData = await getUserData(userId);
            hideInlineLoader(followersListContainer);
            if (!userData || !userData.followers || userData.followers.length === 0) {
                followersListContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No followers yet.</p>';
                return;
            }
            followersListContainer.innerHTML = '';
            for (const followerId of userData.followers) {
                const followerData = await getUserData(followerId);
                if (followerData) {
                    renderUserListItem(followerData, followersListContainer);
                }
            }
        }

        async function loadFollowingPage(userId) {
            followingListContainer.innerHTML = '';
            showInlineLoader(followingListContainer, 'user-list-item', 3);

            const userData = await getUserData(userId);
            hideInlineLoader(followingListContainer);
            if (!userData || !userData.following || userData.following.length === 0) {
                followingListContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Not following anyone yet.</p>';
                return;
            }
            followingListContainer.innerHTML = '';
            for (const followedId of userData.following) {
                const followedData = await getUserData(followedId);
                if (followedData) {
                    renderUserListItem(followedData, followingListContainer);
                }
            }
        }

        function renderUserListItem(userData, container) {
            const userItem = document.createElement('div');
            userItem.className = 'user-list-item';
            userItem.innerHTML = `
                <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                <div class="user-list-info">
                    <h4>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</h4>
                    <p>@${userData.username}</p>
                </div>
            `;
            userItem.addEventListener('click', () => navigateToPage('profile', userData.uid));
            container.appendChild(userItem);
        }


        async function toggleFollow(userIdToToggle, followButtonElement = null) {
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            const currentUserRef = db.collection('users').doc(currentUser.uid);
            const targetUserRef = db.collection('users').doc(userIdToToggle);

            const currentUserData = await getUserData(currentUser.uid);
            const isFollowing = currentUserData.following && currentUserData.following.includes(userIdToToggle);

            const followUpdate = isFollowing ? firebase.firestore.FieldValue.arrayRemove(userIdToToggle) : firebase.firestore.FieldValue.arrayUnion(userIdToToggle);
            const followerUpdate = isFollowing ? firebase.firestore.FieldValue.arrayRemove(currentUser.uid) : firebase.firestore.FieldValue.arrayUnion(currentUser.uid);

            try {
                await currentUserRef.update({ following: followUpdate });
                await targetUserRef.update({ followers: followerUpdate });

                delete userCache[currentUser.uid];
                delete userCache[userIdToToggle];

                if (!isFollowing) {
                    db.collection('notifications').add({
                        type: 'follow',
                        senderUserId: currentUser.uid,
                        recipientUserId: userIdToToggle,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: false
                    });
                }

                if (followButtonElement) {
                    const newIsFollowing = !isFollowing;
                    followButtonElement.classList.toggle('following', newIsFollowing);
                    if (followButtonElement.closest('.reel-user')) {
                        followButtonElement.textContent = newIsFollowing ? 'Following' : 'Follow';
                    } else {
                        followButtonElement.classList.toggle('primary-btn', !newIsFollowing);
                        followButtonElement.classList.toggle('secondary-btn', newIsFollowing);
                        followButtonElement.textContent = newIsFollowing ? 'Following' : 'Follow';
                    }
                }
                if (currentProfileUserId === userIdToToggle || currentProfileUserId === currentUser.uid) {
                    loadProfileContent(currentProfileUserId, document.querySelector('.profile-tab.active')?.dataset.tab || 'posts');
                }
            } catch (error) {
                showNotification("Could not update follow status.", "error");
            }
        }

        async function loadReels(loadMore = false) {
            if (reelsLoading && loadMore) return;
            reelsLoading = true;
            reelsContainer.dataset.isLoadingMore = loadMore.toString();

            if (!loadMore) {
                const header = reelsContainer.querySelector('.reels-header');
                reelsContainer.innerHTML = '';
                if (header) {
                    reelsContainer.appendChild(header);
                } else {
                     reelsContainer.innerHTML = `
                        <div class="reels-header">
                            <button class="back-btn" id="reelsHeaderBackBtn"><i class="fas fa-arrow-left"></i></button>
                            <h3 style="margin: 0;">Reels</h3>
                            <button class="search-btn" id="reelsHeaderSearchBtn"><i class="fas fa-search"></i></button>
                        </div>`;
                    document.getElementById('reelsHeaderBackBtn').addEventListener('click', () => {
                        // Directly handle closing the reels viewer and navigating
                        reelsContainer.style.display = 'none';
                        document.body.style.overflow = 'auto';
                        if (window.innerWidth < 992) {
                            bottomNav.style.display = 'flex';
                        }
                        reelsContainer.querySelectorAll('video').forEach(v => v.pause());
                        if (reelsObserver) reelsObserver.disconnect();
                        lastVisibleReel = null;
                        navigateToPage('home'); // Now navigate
                    });
                    // Updated Search Navigation for Reels Header
                    const reelsHeaderSearchBtn = reelsContainer.querySelector('#reelsHeaderSearchBtn');
                    if (reelsHeaderSearchBtn) {
                        reelsHeaderSearchBtn.addEventListener('click', () => navigateToPage('reelsSearch'));
                    }
                }
                showInlineLoader(reelsContainer, 'reel-item', 1);
            }

            let query = db.collection('posts')
                .where('type', '==', 'reel')
                .orderBy('timestamp', 'desc')
                .limit(POSTS_PER_BATCH);
            if (loadMore && lastVisibleReel) {
                query = query.startAfter(lastVisibleReel);
            }

            try {
                const querySnapshot = await query.get();
                if (!loadMore || querySnapshot.docs.length > 0) {
                    hideInlineLoader(reelsContainer);
                }

                if (querySnapshot.empty) {
                    if (!loadMore && !reelsContainer.querySelector('.reel-item')) {
                        reelsContainer.innerHTML += '<p style="color:white;text-align:center;margin-top:50vh;">No reels found.</p>';
                    }
                    if(reelsObserver) reelsObserver.disconnect();
                    reelsLoading = false;
                    delete reelsContainer.dataset.isLoadingMore;
                    return;
                }

                lastVisibleReel = querySnapshot.docs[querySnapshot.docs.length - 1];
                let reelsAdded = 0;
                for (const doc of querySnapshot.docs) {
                    if (doc.data().mediaType === 'video') {
                        await renderReel(doc.id, doc.data());
                        reelsAdded++;
                    }
                }

                if (reelsAdded === 0 && !loadMore && !reelsContainer.querySelector('.reel-item')) {
                     reelsContainer.innerHTML += '<p style="color:white;text-align:center;margin-top:50vh;">No visible reels.</p>';
                }

                if (querySnapshot.docs.length === POSTS_PER_BATCH) {
                    const lastReelElement = reelsContainer.querySelector('.reel-item:last-child');
                    if (lastReelElement) {
                        if (reelsObserver) reelsObserver.disconnect();
                        reelsObserver = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting && !reelsLoading) {
                                loadReels(true);
                            }
                        }, { threshold: 0.7 });
                        reelsObserver.observe(lastReelElement);
                    }
                } else {
                    if (reelsObserver) reelsObserver.disconnect();
                }

            } catch (error) {
                hideInlineLoader(reelsContainer);
                reelsContainer.innerHTML += '<p style="color:white;text-align:center;margin-top:50vh;">Could not load reels.</p>';
            } finally {
                reelsLoading = false;
                delete reelsContainer.dataset.isLoadingMore;
            }
        }


        async function renderReel(reelId, reel) {
            const reelElement = document.createElement('div');
            reelElement.className = 'reel-item';
            reelElement.dataset.userId = reel.userId; // Store user ID for swipe

            const userData = await getUserData(reel.userId);
            if (!userData) return;

            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            const isLiked = reel.likes && currentUserId ? reel.likes.includes(currentUserId) : false;
            const currentUserData = await getUserData(currentUserId);
            const isFollowing = currentUserData && currentUserData.following ? currentUserData.following.includes(reel.userId) : false;

            reelElement.innerHTML = `
                <div class="media-loading-overlay"><div class="spinner"></div></div>
                <video class="reel-video" loop playsinline src="${reel.mediaUrl}"></video>
                <div class="reel-actions">
                    <div class="reel-action like-btn ${isLiked ? 'liked' : ''}" data-reel-id="${reelId}">
                        <i class="far fa-heart"></i>
                        <span>${reel.likes ? reel.likes.length : 0}</span>
                    </div>
                    <div class="reel-action comment-btn" data-reel-id="${reelId}">
                        <i class="far fa-comment"></i>
                        <span>${reel.commentCount || 0}</span>
                    </div>
                     <div class="reel-action view-count">
                        <i class="fas fa-eye"></i>
                        <span id="view-count-${reelId}">${reel.viewCount || 0}</span>
                    </div>
                    <div class="reel-action share-btn" data-post-id="${reelId}">
                        <i class="fas fa-share"></i>
                        <span>Share</span>
                    </div>
                </div>
                <div class="reel-user">
                    <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User">
                    <span>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</span>
                    ${reel.userId !== currentUserId ? `<button class="follow-button ${isFollowing ? 'following' : ''}" data-user-id="${reel.userId}">${isFollowing ? 'Following' : 'Follow'}</button>` : ''}
                </div>
            `;

            const noReelsMessage = reelsContainer.querySelector('p');
            if (noReelsMessage) {
                reelsContainer.insertBefore(reelElement, noReelsMessage);
            } else {
                const firstSkeleton = reelsContainer.querySelector('.skeleton-reel-item-wrapper');
                if (firstSkeleton) {
                    reelsContainer.insertBefore(reelElement, firstSkeleton);
                } else {
                    reelsContainer.appendChild(reelElement);
                }
            }

            reelElement.querySelector('.like-btn')?.addEventListener('click', () => toggleLike(reelId, reelElement.querySelector('.like-btn'), reelElement.querySelector('.reel-action span')));
            reelElement.querySelector('.comment-btn')?.addEventListener('click', () => showComments(reelId));
            reelElement.querySelector('.share-btn')?.addEventListener('click', () => openShareModal(reelId, 'reel'));
            reelElement.querySelector('.follow-button')?.addEventListener('click', (e) => {
                 e.stopPropagation();
                 toggleFollow(reel.userId, e.currentTarget);
            });

            const video = reelElement.querySelector('.reel-video');
            const overlay = reelElement.querySelector('.media-loading-overlay');

            if (overlay) {
                hideOverlayAfterDelay(overlay, 6300); // 6.3 seconds
            }

            if (video) {
                let tapTimeout;
                const TAP_DELAY = 300;

                video.addEventListener('click', (e) => {
                    clearTimeout(tapTimeout);
                    tapTimeout = setTimeout(() => {
                        if (video.paused) {
                            video.play().catch(e => {});
                        } else {
                            video.pause();
                        }
                    }, TAP_DELAY);
                });

                video.addEventListener('dblclick', (e) => {
                    clearTimeout(tapTimeout);
                    toggleLike(reelId, reelElement.querySelector('.like-btn'), reelElement.querySelector('.reel-action span'));
                });

                let lastTap = 0;
                video.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;

                    if (tapLength < TAP_DELAY && tapLength > 0) {
                        clearTimeout(tapTimeout);
                        toggleLike(reelId, reelElement.querySelector('.like-btn'), reelElement.querySelector('.reel-action span'));
                        lastTap = 0;
                    } else {
                        tapTimeout = setTimeout(() => {
                            if (video.paused) {
                                video.play().catch(e => {});
                            } else {
                                video.pause();
                            }
                        }, TAP_DELAY);
                        lastTap = currentTime;
                    }
                });

                // Swipe detection on reelElement (the container)
                reelElement.addEventListener('touchstart', (e) => {
                    reelSwipeStartX = e.touches[0].clientX;
                    reelSwipeStartY = e.touches[0].clientY;
                }, { passive: true });

                reelElement.addEventListener('touchmove', (e) => {
                    reelSwipeCurrentX = e.touches[0].clientX;
                    reelSwipeCurrentY = e.touches[0].clientY;
                }, { passive: true });

                reelElement.addEventListener('touchend', (e) => {
                    const deltaX = reelSwipeCurrentX - reelSwipeStartX;
                    const deltaY = reelSwipeCurrentY - reelSwipeStartY;

                    if (Math.abs(deltaX) > REEL_SWIPE_THRESHOLD && Math.abs(deltaY) < REEL_SWIPE_THRESHOLD) { // Horizontal swipe
                        if (deltaX > 0) { // Swipe Right
                            const creatorId = reelElement.dataset.userId;
                            if (creatorId) {
                                navigateToPage('profile', creatorId);
                            }
                        }
                    }
                    // Reset swipe coordinates
                    reelSwipeStartX = 0; reelSwipeCurrentX = 0;
                    reelSwipeStartY = 0; reelSwipeCurrentY = 0;
                });


                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const targetVideo = entry.target.querySelector('.reel-video') || entry.target;
                        if (entry.isIntersecting) {
                            // Pause all other videos in the reels container
                            reelsContainer.querySelectorAll('.reel-item video').forEach(otherVideo => {
                                if (otherVideo !== targetVideo) {
                                    otherVideo.pause();
                                    otherVideo.muted = true; // Mute previous video
                                }
                            });
                            // Play the current video
                            targetVideo.play().catch(e => {});
                            targetVideo.muted = false; // Attempt to unmute when it becomes active

                            if (entry.target.dataset.viewed !== 'true') {
                                entry.target.dataset.viewed = 'true';
                                const reelRef = db.collection('posts').doc(reelId);
                                reelRef.update({
                                    viewCount: firebase.firestore.FieldValue.increment(1)
                                }).then(() => {
                                    const viewCountSpan = document.getElementById(`view-count-${reelId}`);
                                    if (viewCountSpan) {
                                        viewCountSpan.textContent = parseInt(viewCountSpan.textContent) + 1;
                                    }
                                });
                            }
                        } else {
                            targetVideo.pause();
                            // targetVideo.muted = true; // Optionally mute when not intersecting
                        }
                    });
                }, { threshold: 0.7 }); // Trigger when 70% of the reel is visible

                observer.observe(reelElement);
            }
        }

        function showReels() {
            const currentPageId = document.querySelector('.feed[style*="block"]')?.id?.replace('Page', '') || 'home';
            const currentParam = window.location.hash.substring(1).split('/')[1] || null;
            reelsContainer.dataset.previousPage = currentPageId;
            if(currentParam) reelsContainer.dataset.previousParam = currentParam;

            reelsContainer.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Keep body scroll hidden for reels view
            // bottomNav is handled by loadReels and handleHashChange now
            loadReels();
        }

        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('key', THUMBSNAP_API_KEY);
            formData.append('media', file);

            try {
                const response = await fetch(THUMBSNAP_UPLOAD_URL, { method: 'POST', body: formData });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Upload failed: ${response.status} ${errorText}`);
                }
                const result = await response.json();
                if (result.status === 200 && result.data && result.data.media) {
                    return result.data.media;
                } else {
                    throw new Error('Upload failed: Invalid response structure.');
                }
            } catch (error) {
                throw error;
            }
        }

        document.getElementById('postForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const user = auth.currentUser;
            if (!user) return;

            const postTextContent = document.getElementById('postText').value; // From Step 1
            const finalPostType = postTypeSelect.value; // From Step 1
            const finalTags = [...currentTags]; // From Step 1

            // From Step 2
            const finalPostLocation = postLocationInput.value.trim();
            const finalPostVisibility = postVisibilitySelect.value;
            const finalEnableMonetization = enableMonetizationCheckbox.checked;
            const scheduleValue = scheduleDateTimeInput.value;

            if (!postTextContent.trim() && currentMediaFiles.length === 0) {
                showNotification("Please add content or media to your post (Step 1).", "info");
                return;
            }
            if (finalPostType === 'reel' && (currentMediaFiles.length === 0 || currentMediaFiles[0].type !== 'video')) {
                showNotification("Reels must be videos. Please select a video in Step 1.", "error");
                return;
            }
            if (finalPostType === 'story' && (currentMediaFiles.length === 0 || currentMediaFiles[0].type !== 'image' || currentMediaFiles.length > 1)) {
                showNotification("Stories must be single images. Please select one image in Step 1.", "error");
                return;
            }
             if (finalPostType === 'post' && currentMediaFiles.length > 1 && currentMediaFiles.some(f => f.type === 'video')) {
                showNotification("You can only upload one video per post. For multiple images, ensure all files are images.", "error");
                return;
            }
            if (scheduleValue) {
                const scheduleDate = new Date(scheduleValue);
                if (scheduleDate <= new Date()) {
                    showNotification("Scheduled time must be in the future.", "error");
                    return;
                }
            }

            postSubmitBtn.disabled = true;
            postSubmitBtn.textContent = scheduleValue ? 'Scheduling...' : 'Posting...';

            // Upload all files in currentMediaFiles
            const uploadPromises = currentMediaFiles.map(mediaFileObj => uploadFile(mediaFileObj.file));

            Promise.all(uploadPromises).then(uploadedUrls => {
                const postData = {
                    userId: user.uid,
                    content: postTextContent,
                    // timestamp will be set on server or based on schedule
                    likes: [],
                    likeCount: 0,
                    commentCount: 0,
                    type: finalPostType,
                    tags: finalTags,
                    location: finalPostLocation,
                    visibility: finalPostVisibility,
                    monetized: (finalPostType === 'post' && finalEnableMonetization),
                    ...(finalPostType === 'reel' && { viewCount: 0 })
                };

                if (uploadedUrls.length > 0) {
                    if (finalPostType === 'post' && currentMediaFiles.length > 1 && currentMediaFiles.every(f => f.type === 'image')) {
                        postData.mediaUrls = uploadedUrls; // Array of URLs
                        postData.mediaType = 'gallery';
                    } else if (currentMediaFiles.length === 1) {
                        postData.mediaUrl = uploadedUrls[0]; // Single URL
                        postData.mediaType = currentMediaFiles[0].type; // 'image' or 'video'
                    }
                    // Story and Reel already validated to have single, correct media type
                     else if (finalPostType === 'story' || finalPostType === 'reel') {
                        postData.mediaUrl = uploadedUrls[0];
                        postData.mediaType = currentMediaFiles[0].type;
                    }
                }


                if (scheduleValue) {
                    postData.scheduledAt = firebase.firestore.Timestamp.fromDate(new Date(scheduleValue));
                    postData.status = 'scheduled'; // Mark as scheduled
                    postData.timestamp = firebase.firestore.FieldValue.serverTimestamp(); // Record creation time
                    return db.collection('scheduledPosts').add(postData);
                } else if (finalPostType === 'story') {
                    const expirationTime = new Date(Date.now() + 24 * 60 * 60 * 1000);
                    postData.expiration = firebase.firestore.Timestamp.fromDate(expirationTime);
                    postData.timestamp = firebase.firestore.FieldValue.serverTimestamp();
                    return db.collection('stories').add(postData);
                } else {
                    postData.timestamp = firebase.firestore.FieldValue.serverTimestamp();
                    return db.collection('posts').add(postData);
                }
            })
            .then(() => {
                // Reset form and state (moved to openCreatePostModal for consistency)
                openCreatePostModal(); // This will effectively reset the modal
                createPostModal.style.display = 'none'; // Then hide it

                showNotification(scheduleValue ? "Post scheduled successfully!" : "Post created successfully!", "success");
            })
            .catch(error => {
                console.error("Error creating/scheduling post: ", error);
                showNotification("Error creating/scheduling post. Please try again.", "error");
            })
            .finally(() => {
                postSubmitBtn.disabled = false;
                // Text content is reset by openCreatePostModal or by scheduleDateTimeInput listener
                postSubmitBtn.textContent = scheduleDateTimeInput.value ? 'Schedule Post' : 'Post Now';
            });
        });

        postTypeSelect.addEventListener('change', () => {
            // This logic is now primarily for Step 2 when it becomes visible
            // or if you want to give immediate feedback in Step 1 (though monetization is in step 2)
            if (createPostStep2Div.style.display === 'block') { // Only adjust if step 2 is visible
                 if (postTypeSelect.value === 'post') {
                    monetizationOptions.style.display = 'block';
                } else {
                    monetizationOptions.style.display = 'none';
                    enableMonetizationCheckbox.checked = false;
                }
            }
             // Additional logic for media selection based on post type
            if (postTypeSelect.value === 'reel') {
                if (currentMediaFiles.length > 0 && currentMediaFiles[0].type !== 'video') {
                    showNotification("Reels require a video. Please change selection or post type.", "warning");
                    clearMediaAndPreview();
                } else if (currentMediaFiles.length > 1) {
                    showNotification("Reels can only have one video. Extra files removed.", "warning");
                    currentMediaFiles = [currentMediaFiles.find(f => f.type === 'video')].filter(Boolean); // Keep first video
                    // Re-render preview for the single video (or clear if none)
                    const multipleImagePreviewContainer = document.getElementById('multipleImagePreview');
                    multipleImagePreviewContainer.innerHTML = '';
                     if(currentMediaFiles.length > 0) {
                        document.getElementById('previewVideo').src = URL.createObjectURL(currentMediaFiles[0].file);
                        document.getElementById('previewVideo').style.display = 'block';
                        document.getElementById('previewContainer').style.display = 'block';
                    } else {
                        clearMediaAndPreview();
                    }
                }
                photoUpload.accept = ""; // No specific restriction, but UI implies video
                videoUpload.accept = "video/*";
            } else if (postTypeSelect.value === 'story') {
                if (currentMediaFiles.length > 0 && currentMediaFiles[0].type !== 'image') {
                    showNotification("Stories require an image. Please change selection or post type.", "warning");
                    clearMediaAndPreview();
                } else if (currentMediaFiles.length > 1) {
                     showNotification("Stories can only have one image. Extra files removed.", "warning");
                    currentMediaFiles = [currentMediaFiles.find(f => f.type === 'image')].filter(Boolean); // Keep first image
                    // Re-render preview for the single image
                    const multipleImagePreviewContainer = document.getElementById('multipleImagePreview');
                    multipleImagePreviewContainer.innerHTML = '';
                    if(currentMediaFiles.length > 0) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            document.getElementById('previewImage').src = event.target.result;
                            document.getElementById('previewImage').style.display = 'block';
                            document.getElementById('previewContainer').style.display = 'block';
                        };
                        reader.readAsDataURL(currentMediaFiles[0].file);
                    } else {
                        clearMediaAndPreview();
                    }
                }
                photoUpload.accept = "image/*";
                videoUpload.accept = ""; // No video for story
            } else { // Standard Post
                photoUpload.accept = "image/*";
                videoUpload.accept = "video/*";
                // If multiple videos were selected and type changed to post, enforce single video
                if (currentMediaFiles.filter(f => f.type === 'video').length > 1) {
                    showNotification("Posts can only have one video. Please re-select or remove extra videos.", "warning");
                    // Potentially clear or ask user to fix
                }
            }
        });


        document.getElementById('addPhoto').addEventListener('click', () => photoUpload.click());

        photoUpload.addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files || files.length === 0) {
                if (isAddingMoreImages) isAddingMoreImages = false; // Reset flag if no file chosen
                updatePreviewUIVisibility(); // Update UI even if no file chosen, to hide "add more" if it was visible
                return;
            }

            if (!isAddingMoreImages) {
                currentMediaFiles = []; // Clear existing files only if not adding more
            }
            // Don't call clearMediaAndPreview() here as it clears too much when isAddingMoreImages is true.
            // Individual preview elements will be managed by updatePreviewUIVisibility.

            let allImages = true;
            for (let i = 0; i < files.length; i++) {
                if (!files[i].type.match('image.*')) {
                    allImages = false;
                    break;
                }
            }

            if (!allImages) {
                showNotification("Please select only image files.", "error");
                photoUpload.value = ""; // Clear the file input
                isAddingMoreImages = false; // Reset flag
                updatePreviewUIVisibility(); // Refresh UI based on potentially unchanged currentMediaFiles
                return;
            }

            const newFilesBatch = [];
            for (let i = 0; i < files.length; i++) {
                newFilesBatch.push({ file: files[i], type: 'image', id: Date.now() + i });
            }

            if (isAddingMoreImages) {
                currentMediaFiles.push(...newFilesBatch);
            } else {
                currentMediaFiles = newFilesBatch;
            }

            if (currentMediaFiles.length > 5) {
                showNotification("You can upload a maximum of 5 images. Excess files removed.", "info");
                currentMediaFiles = currentMediaFiles.slice(0, 5);
            }

            photoUpload.value = ""; // Always reset file input to allow re-selection of same file(s)
            isAddingMoreImages = false; // Reset flag after processing

            updatePreviewUIVisibility(); // Centralized UI update

            // Handle type specific constraints after updating previews
            if (postTypeSelect.value === 'story' && currentMediaFiles.length > 1) {
                showNotification("Stories can only have one image. Please select a single image.", "warning");
                currentMediaFiles = [currentMediaFiles[0]]; // Keep only the first one
                updatePreviewUIVisibility();
            }
            if (postTypeSelect.value === 'reel' && currentMediaFiles.length > 0) {
                 showNotification("Reels must be videos. Please select a video or change post type.", "error");
                 currentMediaFiles = []; // Clear images if type is reel
                 updatePreviewUIVisibility();
            }
        });

        document.getElementById('addVideo').addEventListener('click', () => videoUpload.click());

        videoUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.match('video.*')) {
                showNotification("Please select a video file.", "error");
                videoUpload.value = "";
                updatePreviewUIVisibility(); // Update UI if no valid file
                return;
            }

            currentMediaFiles = [{ file: file, type: 'video', id: Date.now() }];
            videoUpload.value = ""; // Reset file input

            if (postTypeSelect.value === 'story') {
                showNotification("Stories must be images. Post type changed to 'Reel'.", "warning");
                postTypeSelect.value = 'reel';
                 monetizationOptions.style.display = 'none';
                 enableMonetizationCheckbox.checked = false;
            }
            updatePreviewUIVisibility();
        });

        function clearMediaAndPreview() {
            // This function is now primarily for the main "X" remove button
            currentMediaFiles = [];
            isAddingMoreImages = false; // Ensure this is reset

            // Reset file inputs
            photoUpload.value = "";
            videoUpload.value = "";

            updatePreviewUIVisibility(); // Update UI to reflect no media
        }


        document.getElementById('removePreview').addEventListener('click', () => {
            currentMediaFiles = []; // Clear the array fully
            isAddingMoreImages = false; // Reset flag
            clearMediaAndPreview(); // Call original clear for inputs
            updatePreviewUIVisibility(); // Then update UI based on empty array
        });

        function updatePreviewUIVisibility() {
            const multipleImagePreviewContainer = document.getElementById('multipleImagePreview');
            const singlePreviewImage = document.getElementById('previewImage');
            const addMoreBtn = document.getElementById('addMoreImageBtn');
            const videoPreview = document.getElementById('previewVideo');
            const previewContainer = document.getElementById('previewContainer');

            // Hide all previews initially
            singlePreviewImage.style.display = 'none';
            videoPreview.style.display = 'none';
            multipleImagePreviewContainer.style.display = 'none';
            multipleImagePreviewContainer.innerHTML = ''; // Clear thumbnails
            if(addMoreBtn) addMoreBtn.style.display = 'none'; // Check if exists
            previewContainer.style.display = 'none';


            if (currentMediaFiles.length === 0) {
                // No media, ensure remove preview button is also hidden if it's not already handled by clearMediaAndPreview
                document.getElementById('removePreview').style.display = 'none';
            } else {
                previewContainer.style.display = 'flex'; // Use flex for the container
                document.getElementById('removePreview').style.display = 'block';

                if (currentMediaFiles[0].type === 'video') {
                    videoPreview.src = URL.createObjectURL(currentMediaFiles[0].file);
                    videoPreview.style.display = 'block';
                } else if (currentMediaFiles.length === 1 && postTypeSelect.value === 'post') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        singlePreviewImage.src = event.target.result;
                        singlePreviewImage.style.display = 'block';
                    };
                    reader.readAsDataURL(currentMediaFiles[0].file);
                    if(addMoreBtn) addMoreBtn.style.display = 'flex';
                } else if (currentMediaFiles.every(f => f.type === 'image')) { // Multiple images
                    multipleImagePreviewContainer.style.display = 'flex';
                    currentMediaFiles.forEach(mediaFile => {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const thumbWrapper = document.createElement('div');
                            thumbWrapper.style.position = 'relative';
                            thumbWrapper.style.marginRight = '10px';
                            thumbWrapper.style.marginBottom = '10px';
                            thumbWrapper.dataset.fileId = mediaFile.id;

                            const img = document.createElement('img');
                            img.src = event.target.result;
                            img.style.width = '80px';
                            img.style.height = '80px';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '4px';
                            thumbWrapper.appendChild(img);

                            const removeBtnThumb = document.createElement('button');
                            removeBtnThumb.innerHTML = '&times;';
                            removeBtnThumb.style.position = 'absolute';
                            removeBtnThumb.style.top = '0px';
                            removeBtnThumb.style.right = '0px';
                            removeBtnThumb.style.background = 'rgba(0,0,0,0.6)';
                            removeBtnThumb.style.color = 'white';
                            removeBtnThumb.style.border = 'none';
                            removeBtnThumb.style.borderRadius = '50%';
                            removeBtnThumb.style.width = '20px';
                            removeBtnThumb.style.height = '20px';
                            removeBtnThumb.style.lineHeight = '20px';
                            removeBtnThumb.style.textAlign = 'center';
                            removeBtnThumb.style.cursor = 'pointer';
                            removeBtnThumb.style.fontSize = '14px';
                            removeBtnThumb.onclick = function() {
                                const idToRemove = parseInt(thumbWrapper.dataset.fileId);
                                currentMediaFiles = currentMediaFiles.filter(f => f.id !== idToRemove);
                                updatePreviewUIVisibility();
                            };
                            thumbWrapper.appendChild(removeBtnThumb);
                            multipleImagePreviewContainer.appendChild(thumbWrapper);
                        };
                        reader.readAsDataURL(mediaFile.file);
                    });
                }
            }

            const hasText = document.getElementById('postText').value.trim().length > 0;
            postNextBtn.disabled = !(hasText || currentMediaFiles.length > 0);
            postNextBtn.classList.toggle('active', hasText || currentMediaFiles.length > 0);
        }

        document.getElementById('postText').addEventListener('input', function() {
            const hasText = this.value.trim().length > 0;
            const hasMedia = currentMediaFiles.length > 0;
            postNextBtn.disabled = !(hasText || hasMedia);
            postNextBtn.classList.toggle('active', hasText || hasMedia);
        });

        postTagsInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ',') {
                e.preventDefault();
                const tagText = postTagsInput.value.trim().replace(/,/g, '');
                if (tagText && !currentTags.includes(tagText)) {
                    currentTags.push(tagText);
                    renderTags();
                    postTagsInput.value = '';
                }
            }
        });

        function renderTags() {
            tagsDisplay.innerHTML = '';
            currentTags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag-item';
                tagElement.innerHTML = `#${tag} <span class="remove-tag" data-tag="${tag}">&times;</span>`;
                tagsDisplay.appendChild(tagElement);
            });
            tagsDisplay.querySelectorAll('.remove-tag').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    currentTags = currentTags.filter(t => t !== e.target.dataset.tag);
                    renderTags();
                });
            });
        }

        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
            if (e.target.classList.contains('chat-modal')) {
                closeChatModal.click();
            }
        });

        async function loadExploreContent(tab = 'forYou', loadMore = false) {
            if (exploreLoading && loadMore) return;
            exploreLoading = true;
            if(exploreContent) exploreContent.dataset.isLoadingMore = loadMore.toString();

            // Hide all specific view containers first
            if(forYouViewContent) forYouViewContent.style.display = 'none';
            if(exploreHashtagsViewContent) exploreHashtagsViewContent.style.display = 'none';

            if (currentExploreView === 'forYou') {
                if(forYouViewContent) forYouViewContent.style.display = 'block';
                if (!loadMore) { // Full reload for "For You"
                    const popularReelsContainer = document.getElementById('popularReelsContainer');
                    const popularPostsContainer = document.getElementById('popularPostsContainer');
                    if(popularReelsContainer) popularReelsContainer.innerHTML = '';
                    if(popularPostsContainer) popularPostsContainer.innerHTML = '';

                    lastVisiblePopularPost = null;
                    if(popularReelsContainer) showInlineLoader(popularReelsContainer, 'reel-grid-item', 3);
                    if(popularPostsContainer) showInlineLoader(popularPostsContainer, 'post', EXPLORE_POSTS_PER_BATCH);

                    await loadPopularReels();
                    await loadPopularPosts(false); // Initial load for posts
                } else { // Loading more for popular posts
                    await loadPopularPosts(true);
                }
            } else if (currentExploreView === 'exploreHashtags') {
                exploreHashtagsViewContent.style.display = 'block';
                if (!loadMore) {
                    exploreHashtagsContainer.innerHTML = '';
                    lastVisibleTaggedPost = null;
                    showInlineLoader(exploreHashtagsContainer, 'post', EXPLORE_POSTS_PER_BATCH);
                }
                await loadTaggedPosts(loadMore);
            }

            exploreLoading = false;
            delete exploreContent.dataset.isLoadingMore;
        }

        async function loadPopularReels() {
            const container = document.getElementById('popularReelsContainer');
            hideInlineLoader(container);
            container.innerHTML = ''; // Clear before loading

            try {
                const querySnapshot = await db.collection('posts')
                    .where('type', '==', 'reel')
                    .orderBy('likeCount', 'desc')
                    .limit(3)
                    .get();

                if (querySnapshot.empty) {
                    container.innerHTML = '<p style="color:var(--gray-color); font-size:14px; text-align:center; width:100%;">No popular reels found.</p>';
                    return;
                }
                querySnapshot.forEach(doc => {
                    renderReelCardForExplore(doc.id, doc.data(), container);
                });
            } catch (error) {
                console.error("Error loading popular reels: ", error);
                container.innerHTML = '<p style="color:var(--danger-color); font-size:14px; text-align:center; width:100%;">Could not load popular reels.</p>';
            }
        }

        function renderReelCardForExplore(reelId, reelData, container) {
            const reelCard = document.createElement('div');
            reelCard.className = 'explore-reel-item horizontal-reel-card';

            reelCard.innerHTML = `
                <video src="${reelData.mediaUrl}" muted loop playsinline autoplay style="width:100%; height:100%; object-fit:cover;"></video>
                <div class="reel-view-count" style="position:absolute; top:8px; right:8px; font-size:11px; color:white; background-color:rgba(0,0,0,0.4); padding:2px 5px; border-radius:4px;">
                    <i class="fas fa-heart" style="margin-right:3px;"></i> ${reelData.likeCount || 0}
                </div>
            `;
            reelCard.addEventListener('click', () => showReels(reelId));
            container.appendChild(reelCard);
        }

        function renderReelCardForHorizontalList(reelId, reelData, container) {
            const reelCard = document.createElement('div');
            reelCard.className = 'explore-reel-item horizontal-reel-card'; // Class controls dimensions via CSS now

            const userData = userCache[reelData.userId]; // Assume userData might be pre-fetched or use await getUserData

            reelCard.innerHTML = `
                <video src="${reelData.mediaUrl}" muted playsinline style="width:100%; height:100%; object-fit:cover;"></video>
                <div class="reel-user-info" style="position:absolute; bottom:8px; left:8px; font-size:12px; color:white; text-shadow: 0 1px 2px rgba(0,0,0,0.7);">
                    ${userData ? `<img src="${userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`}" alt="${userData.username}" style="width:20px; height:20px; border-radius:50%; margin-right:5px; display:inline-block; vertical-align:middle;">` : ''}
                    ${userData ? userData.username : 'User'}
                </div>
                <div class="reel-view-count" style="position:absolute; top:8px; right:8px; font-size:11px; color:white; background-color:rgba(0,0,0,0.4); padding:2px 5px; border-radius:4px;">
                    <i class="fas fa-eye" style="margin-right:3px;"></i> ${reelData.viewCount || 0}
                </div>
            `;
            reelCard.addEventListener('click', () => showReels(reelId)); // Pass reelId to potentially open specific reel
            container.appendChild(reelCard);
        }


        async function loadPopularPosts(loadMore = false) {
            if (!loadMore) {
                hideInlineLoader(popularPostsContainer);
                popularPostsContainer.innerHTML = '';
            }

            let query = db.collection('posts')
                .where('type', '==', 'post') // Only posts, not reels here
                .orderBy('likeCount', 'desc') // Example: order by likes
                .limit(EXPLORE_POSTS_PER_BATCH);

            if (loadMore && lastVisiblePopularPost) {
                query = query.startAfter(lastVisiblePopularPost);
            }

            try {
                const querySnapshot = await query.get();
                 hideInlineLoader(popularPostsContainer); // Hide any remaining loaders

                if (querySnapshot.empty && !loadMore) {
                    popularPostsContainer.innerHTML = '<p style="color:var(--gray-color); text-align:center;">No popular posts found.</p>';
                    return;
                }
                if (querySnapshot.empty && loadMore) {
                    // No more posts to load
                    if (exploreObserver) exploreObserver.disconnect();
                    return;
                }

                lastVisiblePopularPost = querySnapshot.docs[querySnapshot.docs.length - 1];

                querySnapshot.forEach(doc => {
                    renderPost(doc.id, doc.data(), popularPostsContainer); // Assumes renderPost appends to a grid
                });

                if (querySnapshot.docs.length === EXPLORE_POSTS_PER_BATCH && popularPostsContainer.lastElementChild) {
                    setupExploreObserver(popularPostsContainer.lastElementChild, () => loadPopularPosts(true));
                } else {
                    if (exploreObserver) exploreObserver.disconnect();
                }
            } catch (error) {
                console.error("Error loading popular posts: ", error);
                 hideInlineLoader(popularPostsContainer);
                popularPostsContainer.innerHTML = '<p style="color:var(--danger-color); text-align:center;">Could not load popular posts.</p>';
            }
        }

        async function loadTaggedPosts(loadMore = false) {
            if (!loadMore) {
                hideInlineLoader(exploreHashtagsContainer);
                exploreHashtagsContainer.innerHTML = '';
            }

            let query = db.collection('posts')
                .where('tags', '!=', []) // Basic check for posts that have tags array not empty
                                         // Firestore doesn't directly support "array is not empty"
                                         // A better way is to have a boolean `hasTags` field or query specific tags.
                                         // For now, this query might not be efficient or work as expected.
                                         // A workaround: fetch posts and filter client-side, or restructure data.
                                         // Let's assume for now we fetch recent posts and filter.
                .orderBy('timestamp', 'desc')
                .limit(EXPLORE_POSTS_PER_BATCH * 2); // Fetch more to filter client-side

            if (loadMore && lastVisibleTaggedPost) {
                query = query.startAfter(lastVisibleTaggedPost);
            }

            try {
                const querySnapshot = await query.get();
                hideInlineLoader(exploreHashtagsContainer);

                const taggedDocs = querySnapshot.docs.filter(doc => doc.data().tags && doc.data().tags.length > 0);

                if (taggedDocs.length === 0 && !loadMore) {
                    exploreHashtagsContainer.innerHTML = '<p style="color:var(--gray-color); text-align:center;">No posts with tags found.</p>';
                    return;
                }
                 if (taggedDocs.length === 0 && loadMore) {
                    if (exploreObserver) exploreObserver.disconnect();
                    return;
                }

                lastVisibleTaggedPost = querySnapshot.docs[querySnapshot.docs.length - 1]; // Use original snapshot for pagination cursor

                taggedDocs.slice(0, EXPLORE_POSTS_PER_BATCH).forEach(doc => { // Display up to batch size after filtering
                    renderPost(doc.id, doc.data(), exploreHashtagsContainer);
                });

                if (taggedDocs.length >= EXPLORE_POSTS_PER_BATCH && exploreHashtagsContainer.lastElementChild) {
                     // This lazy load might fetch items that are then filtered out, leading to multiple fetches.
                     // True server-side pagination on tagged content is more complex.
                    setupExploreObserver(exploreHashtagsContainer.lastElementChild, () => loadTaggedPosts(true));
                } else {
                    if (exploreObserver) exploreObserver.disconnect();
                }

            } catch (error) {
                console.error("Error loading tagged posts: ", error);
                hideInlineLoader(exploreHashtagsContainer);
                exploreHashtagsContainer.innerHTML = '<p style="color:var(--danger-color); text-align:center;">Could not load tagged posts.</p>';
            }
        }


        function setupExploreObserver(elementToObserve, callback) {
            if (exploreObserver) exploreObserver.disconnect();
            exploreObserver = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting && !exploreLoading) {
                    callback();
                }
            }, { threshold: 0.5 });
            exploreObserver.observe(elementToObserve);
        }

        exploreTabButtons.forEach(button => {
            button.addEventListener('click', function() {
                exploreTabButtons.forEach(btn => {
                    btn.classList.remove('active');
                    btn.style.color = 'var(--gray-color)';
                    btn.style.fontWeight = '500';
                    btn.style.borderBottomColor = 'transparent';
                });
                this.classList.add('active');
                this.style.color = 'var(--primary-color)';
                this.style.fontWeight = '600';
                this.style.borderBottomColor = 'var(--primary-color)';

                currentExploreView = this.dataset.exploreView;
                // Reset pagination markers for the new view
                lastVisiblePopularPost = null;
                lastVisibleTaggedPost = null;
                if(exploreObserver) exploreObserver.disconnect(); // Important to disconnect old observer
                loadExploreContent(false); // Load the new view from scratch
            });
        });

        // Horizontal Swipe Logic for Popular Reels
        if (popularReelsContainer) {
            let isDown = false;
            let startX;
            let scrollLeft;

            popularReelsContainer.addEventListener('mousedown', (e) => {
                isDown = true;
                popularReelsContainer.classList.add('active-swipe'); // Optional: for styling during swipe
                startX = e.pageX - popularReelsContainer.offsetLeft;
                scrollLeft = popularReelsContainer.scrollLeft;
                e.preventDefault(); // Prevent text selection, etc.
            });

            popularReelsContainer.addEventListener('mouseleave', () => {
                isDown = false;
                popularReelsContainer.classList.remove('active-swipe');
            });

            popularReelsContainer.addEventListener('mouseup', () => {
                isDown = false;
                popularReelsContainer.classList.remove('active-swipe');
            });

            popularReelsContainer.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                const x = e.pageX - popularReelsContainer.offsetLeft;
                const walk = (x - startX) * 1.5; // Adjust multiplier for scroll speed
                popularReelsContainer.scrollLeft = scrollLeft - walk;
            });

            // Touch events for mobile
            popularReelsContainer.addEventListener('touchstart', (e) => {
                isDown = true;
                // For touch, clientX is on the touch object
                startX = e.touches[0].clientX - popularReelsContainer.offsetLeft;
                scrollLeft = popularReelsContainer.scrollLeft;
                 // No e.preventDefault() here for touchstart to allow normal vertical scroll on page if swipe isn't primarily horizontal
            }, { passive: true }); // passive:true can improve scroll performance

            popularReelsContainer.addEventListener('touchend', () => {
                isDown = false;
            });

            popularReelsContainer.addEventListener('touchmove', (e) => {
                if (!isDown) return;
                // Check if primarily horizontal swipe
                // This is a very basic check; more sophisticated gesture detection might be needed
                // if there are issues with vertical page scroll.
                // For now, we assume horizontal movement implies intent to scroll the container.
                const x = e.touches[0].clientX - popularReelsContainer.offsetLeft;
                const walk = (x - startX) * 1.5; // Adjust multiplier
                popularReelsContainer.scrollLeft = scrollLeft - walk;
                // If significant horizontal scroll happened, you might want to e.preventDefault() here
                // but it's tricky with passive listeners. For now, this setup often works okay.
            }, { passive: true });
        }


        async function renderExploreReelItem(reelId, reel, container) { // This is the original explore reel item for grids
            const reelElement = document.createElement('div');
            reelElement.className = 'explore-reel-item';

            const userData = await getUserData(reel.userId);
            if (!userData) return;

            reelElement.innerHTML = `
                <video src="${reel.mediaUrl}" muted playsinline></video>
                <div class="reel-user-info">
                    <img src="${userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`}" alt="User">
                    <span>${userData.name}</span>
                </div>
            `;
            reelElement.addEventListener('click', () => showReels());
            container.appendChild(reelElement);
        }

        function loadStories(storiesContainer) {
            if (!storiesContainer) {
                storiesContainer = exploreContent.querySelector('.stories-container');
                if (!storiesContainer) {
                    storiesContainer = document.createElement('div');
                    storiesContainer.className = 'stories-container';
                    exploreContent.innerHTML = '';
                    exploreContent.appendChild(storiesContainer);
                }
            }

            if (!storiesContainer.querySelector('.skeleton-story-item-wrapper') && storiesContainer.children.length <= (auth.currentUser ? 1 : 0) ) { // Only show skeletons if no actual stories and only add-story button exists
                showInlineLoader(storiesContainer, 'story', 5);
            }


            const currentUser = auth.currentUser;
            if (currentUser) {
                if (!storiesContainer.querySelector('.add-story')) {
                    const addStoryItem = document.createElement('div');
                    addStoryItem.className = 'story-item add-story';
                    addStoryItem.innerHTML = `
                        <i class="fas fa-plus"></i>
                        <span>Add Story</span>
                    `;
                    addStoryItem.addEventListener('click', () => {
                        document.getElementById('createPostModal').style.display = 'flex';
                        postTypeSelect.value = 'story';
                    });
                    storiesContainer.appendChild(addStoryItem);
                }
            }


            if (unsubscribeStories) unsubscribeStories();

            const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

            unsubscribeStories = db.collection('stories')
                .where('expiration', '>', firebase.firestore.Timestamp.fromDate(twentyFourHoursAgo))
                .orderBy('expiration', 'desc')
                .onSnapshot(async (querySnapshot) => {
                    hideInlineLoader(storiesContainer);
                    storiesContainer.querySelectorAll('.story-item:not(.add-story)').forEach(item => item.remove());

                    groupedStories = {};

                    if (querySnapshot.empty && !currentUser) {
                        storiesContainer.innerHTML = '<p class="text-center text-gray-500 p-4">No active stories.</p>';
                        return;
                    }

                    querySnapshot.forEach(doc => {
                        const storyData = { id: doc.id, ...doc.data() };
                        if (!groupedStories[storyData.userId]) {
                            groupedStories[storyData.userId] = [];
                        }
                        groupedStories[storyData.userId].push(storyData);
                    });

                    const userStoryGroups = Object.values(groupedStories).sort((a, b) => {
                        const lastStoryA = a[0].timestamp ? a[0].timestamp.toDate() : new Date(0);
                        const lastStoryB = b[0].timestamp ? b[0].timestamp.toDate() : new Date(0);
                        return lastStoryB - lastStoryA;
                    });

                    for (const userStories of userStoryGroups) {
                        await renderStoryItem(userStories[0].userId, userStories, storiesContainer);
                    }
                    if (userStoryGroups.length === 0 && !storiesContainer.querySelector('.add-story')) {
                         storiesContainer.innerHTML = '<p class="text-center text-gray-500 p-4">No active stories.</p>';
                    }

                }, error => {
                    hideInlineLoader(storiesContainer);
                    storiesContainer.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Could not load stories.</p>';
                });
        }

        async function renderStoryItem(userId, userStories, container) {
            const userData = await getUserData(userId);
            if (!userData) return;

            const storyElement = document.createElement('div');
            // storyElement.className = 'story-item'; // Old class
            storyElement.className = 'story'; // New class from provided CSS

            const isMyStory = auth.currentUser && userId === auth.currentUser.uid;
            // Determine if any story by this user has been viewed by the current user
            // This is a simplified check. A more robust system would track views per story.
            const hasViewedAny = false; // Placeholder: Real view tracking would be complex here.

            // Constructing img and span directly as per new .story > img, .story > span CSS
            const imgElement = document.createElement('img');
            imgElement.src = userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`;
            imgElement.alt = userData.username; // Alt text for accessibility
            // Modifiers like .my-story-avatar or .viewed can still be applied to the img tag itself
            if (isMyStory) {
                imgElement.classList.add('my-story-avatar'); // Assumes .my-story-avatar styles border for .story img
            } else if (hasViewedAny) { // This logic needs actual implementation if "viewed" state is per user
                imgElement.classList.add('viewed'); // Assumes .viewed styles border for .story img
            }

            const spanElement = document.createElement('span');
            spanElement.textContent = userData.username;

            storyElement.appendChild(imgElement);
            storyElement.appendChild(spanElement);

            storyElement.addEventListener('click', () => {
                openStoryModal(userId);
            });

            // Logic for inserting before "Add Story" button
            const addStoryButton = container.querySelector('.story-item.add-story'); // Keep selector for add-story button
            if (addStoryButton) {
                container.insertBefore(storyElement, addStoryButton);
            } else {
                container.appendChild(storyElement);
            }
        }

        async function openStoryModal(selectedUserId) {
            currentViewingUserStories = groupedStories[selectedUserId] || [];
            currentStoryIndex = 0;
            updateStoryModalContent();
            storyModal.style.display = 'flex';
            bottomNav.style.display = 'none';
        }

        async function updateStoryModalContent() {
            if (currentViewingUserStories.length === 0) {
                closeStoryModal.click();
                return;
            }

            const story = currentViewingUserStories[currentStoryIndex];
            if (!story) {
                closeStoryModal.click();
                return;
            }

            const userData = await getUserData(story.userId);
            if (!userData) {
                closeStoryModal.click();
                return;
            }

            storyUserAvatar.src = userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png';
            storyUsername.innerHTML = `${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}`;

            if (story.mediaType === 'image') {
                storyImage.src = story.mediaUrl;
                storyImage.style.display = 'block';
                storyVideo.style.display = 'none';
                storyVideo.pause();
                storyVideo.src = '';
            } else {
                storyVideo.src = story.mediaUrl;
                storyVideo.style.display = 'block';
                storyImage.style.display = 'none';
                storyVideo.play();
            }

            const currentUserId = auth.currentUser ? auth.currentUser.uid : null;
            const isLiked = story.likes && currentUserId ? story.likes.includes(currentUserId) : false;
            storyLikeBtn.classList.toggle('liked', isLiked);

            prevStoryBtn.style.display = currentStoryIndex > 0 ? 'block' : 'none';
            nextStoryBtn.style.display = currentStoryIndex < currentViewingUserStories.length - 1 ? 'block' : 'none';
        }

        prevStoryBtn.addEventListener('click', () => {
            if (currentStoryIndex > 0) {
                currentStoryIndex--;
                updateStoryModalContent();
            }
        });

        nextStoryBtn.addEventListener('click', () => {
            if (currentStoryIndex < currentViewingUserStories.length - 1) {
                currentStoryIndex++;
                updateStoryModalContent();
            }
        });

        storyLikeBtn.addEventListener('click', () => {
            if (currentViewingUserStories[currentStoryIndex]) {
                toggleLike(currentViewingUserStories[currentStoryIndex].id, storyLikeBtn, null, 'story');
            }
        });

        storySendReplyBtn.addEventListener('click', async () => {
            const replyText = storyReplyInput.value.trim();
            if (!replyText || !auth.currentUser || !currentViewingUserStories[currentStoryIndex]) {
                showNotification("Reply cannot be empty.", "info");
                return;
            }

            const story = currentViewingUserStories[currentStoryIndex];
            if (story.userId === auth.currentUser.uid) {
                showNotification("You cannot reply to your own story.", "info");
                return;
            }

            try {
                await db.collection('notifications').add({
                    type: 'story_reply',
                    senderUserId: auth.currentUser.uid,
                    recipientUserId: story.userId,
                    storyId: story.id,
                    replyText: replyText,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    read: false
                });
                showNotification("Reply sent!", "success");
                storyReplyInput.value = '';
            } catch (error) {
                showNotification("Failed to send reply.", "error");
            }
        });


        closeStoryModal.addEventListener('click', () => {
            storyModal.style.display = 'none';
            storyVideo.pause();
            storyVideo.src = '';
            storyImage.src = '';
            // bottomNav.style.display = 'flex'; // Problematic line - Replaced by handleHashChange or explicit check
            // Call handleHashChange to correctly set bottomNav display based on current context and screen size
            handleHashChange();
        });

        auth.onAuthStateChanged(async (user) => {
            if (user) {
                const userData = await getUserData(user.uid);

                if (!user.emailVerified) {
                    authContainer.style.display = 'block';
                    appContainer.style.display = 'none';
                    loginContainer.style.display = 'flex';
                    signupContainer.style.display = 'none';
                    loginError.textContent = 'Please verify your email address before logging in.';
                    showNotification('Please verify your email address.', 'error');
                    auth.signOut();
                    return;
                }

                if (userData && !userData.isProfileSetupComplete) {
                    isFirstTimeSetup = true;
                    authContainer.style.display = 'none';
                    appContainer.style.display = 'block';
                    document.getElementById('contentArea').style.display = 'none';
                    document.getElementById('bottomNav').style.display = 'none';
                    document.querySelector('.sidebar').style.display = 'none';
                    openEditProfileModal(true);
                } else {
                    isFirstTimeSetup = false;
                    document.body.classList.remove('auth-active'); // Remove body class
                    authContainer.style.display = 'none';
                    appContainer.style.display = 'block';
                    document.getElementById('contentArea').style.display = 'flex';
                    // Sidebar display is handled by CSS media queries mostly, ensure it's not 'none' from JS
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar) sidebar.style.display = ''; // Reset if previously set to none by JS

                    loadCurrentUserData();
                    db.collection('users').doc(user.uid).update({ onlineStatus: true }).catch(e => {});

                    if (unsubscribeCurrentUserStatus) unsubscribeCurrentUserStatus();
                    unsubscribeCurrentUserStatus = db.collection('users').doc(user.uid)
                        .onSnapshot(doc => {
                            if (doc.exists) {
                                userCache[user.uid] = {...doc.data(), uid: user.uid};
                            }
                        });

                    handleHashChange();
                }

            } else {
                unsubscribeAll();
                document.body.classList.add('auth-active'); // Add body class
                appContainer.style.display = 'none';
                authContainer.style.display = 'flex'; // New auth page uses flex for centering
                
                // Default to login tab if no specific auth hash or invalid one
                const currentHash = window.location.hash.substring(1);
                if (currentHash !== 'login' && currentHash !== 'signup') {
                    window.location.hash = 'login'; // This will trigger handleHashChange
                } else {
                     handleHashChange(); // Call to correctly show login/signup tab based on hash
                }
                // Ensure correct tab is active based on the hash after setting authContainer display
                if (document.getElementById('loginTab') && document.getElementById('signupTab')) {
                    if (window.location.hash === '#signup') {
                        document.getElementById('signupTab').click();
                    } else {
                        document.getElementById('loginTab').click();
                    }
                }
            }
        });

        window.addEventListener('beforeunload', async () => {
            const user = auth.currentUser;
            if (user) {
                try {
                    await db.collection('users').doc(user.uid).update({ onlineStatus: false });
                } catch (error) {}
            }
        });

        function navigateToPage(pageId, param = null, searchFilter = null) {
            if (reelsContainer.style.display === 'block') {
                // If reels are open, clicking the 'reels' icon again should close it.
                if (pageId === 'reels') {
                    document.getElementById('reelsHeaderBackBtn').click();
                    return; // Stop further processing
                }
                // For any other page, just hide the container first. The rest of the cleanup is in the back button click.
                reelsContainer.style.display = 'none';
                document.body.style.overflow = 'auto';
            }

            let newHash = pageId;
            if (param) newHash += `/${param}`;
            if (searchFilter) newHash += `?filter=${searchFilter}`;

            if (window.location.hash !== `#${newHash}`) {
                window.location.hash = newHash;
            } else {
                handleHashChange(); // Force re-evaluation if hash is the same
            }
        }

        function handleHashChange() {
            const oldPageId = document.querySelector('.feed[style*="block"]')?.id?.replace('Page', '');

            // Unsubscribe logic should be conditional based on whether user is logged in or not
            // If logging out, unsubscribeAll is called in onAuthStateChanged
            // If navigating while logged in, specific listeners might be unsubscribed/re-subscribed.
            // For simplicity now, ensure this doesn't break logout flow.
            if(auth.currentUser) {
                unsubscribeAll(); // Keep for now, might need refinement for SPA navigation performance
            }

            const hash = window.location.hash.substring(1) || (auth.currentUser ? 'home' : 'login');
            const [pagePath, queryString] = hash.split('?');
            const [pageId, param] = pagePath.split('/');

            let searchFilter = null;
            if (queryString) {
                const params = new URLSearchParams(queryString);
                searchFilter = params.get('filter');
            }

            if (!auth.currentUser) {
                document.body.classList.add('auth-active');
                appContainer.style.display = 'none';
                authContainer.style.display = 'flex'; // Use flex for centering new auth page

                const loginTabEl = document.getElementById('loginTab');
                const signupTabEl = document.getElementById('signupTab');

                if (pageId === 'login' && loginTabEl) {
                    loginTabEl.click(); // Activate login tab
                } else if (pageId === 'signup' && signupTabEl) {
                    signupTabEl.click(); // Activate signup tab
                } else if (loginTabEl) {
                    // Default to login if hash is not 'login' or 'signup' explicitly
                    loginTabEl.click();
                    if (window.location.hash !== '#login') window.location.hash = 'login';
                }
                return;
            }

            // If user is logged in, ensure auth-active class is removed
            document.body.classList.remove('auth-active');
            authContainer.style.display = 'none'; // Ensure auth container is hidden
            appContainer.style.display = 'block'; // Ensure app container is visible


            if (isFirstTimeSetup && editProfileModal.style.display !== 'flex') {
                openEditProfileModal(true);
                return;
            }

            // Special handling for exiting reels via bottom nav to home
            if (oldPageId === 'reels' && pageId === 'home' && reelsContainer.style.display === 'block') {
                 reelsContainer.style.display = 'none';
                 document.body.style.overflow = 'auto';
                 reelsContainer.querySelectorAll('video').forEach(v => v.pause());
                 if (reelsObserver) reelsObserver.disconnect();
                 lastVisibleReel = null;
            }


            document.querySelectorAll('.feed').forEach(p => p.style.display = 'none');
            const pageElement = document.getElementById(pageId + 'Page');
            if(pageElement) pageElement.style.display = 'block';

            document.querySelectorAll('.nav-link, .nav-icon').forEach(i => i.classList.remove('active'));
            document.querySelectorAll(`.sidebar .nav-link[data-page="${pageId}"]`).forEach(i => i.classList.add('active'));
            document.querySelectorAll(`.bottom-nav .nav-icon[data-page="${pageId}"]`).forEach(i => {
                if (i.id !== 'searchIconMobile') {
                    i.classList.add('active');
                }
            });


            // Control bottomNav visibility
            const isLargeScreen = window.innerWidth >= 992;
            const shouldHideBottomNavForPageOrModal =
                chatModal.style.display === 'flex' ||
                storyModal.style.display === 'flex' ||
                reelsContainer.style.display === 'block' || // Fullscreen reels view
                // pageId === 'search' || // Search page should show bottom nav
                pageId === 'reelsSearch' || // Reels search is full-screen like
                pageId === 'followers' ||
                pageId === 'following' ||
                editProfileModal.style.display === 'flex'; // During first time setup

            if (isLargeScreen) {
                bottomNav.style.display = 'none';
            } else {
                bottomNav.style.display = shouldHideBottomNavForPageOrModal ? 'none' : 'flex';
            }

            switch (pageId) {
                case 'home': loadHomeFeed(); break;
                case 'explore': loadExploreContent(); break;
                case 'notifications': loadNotifications(); break;
                case 'messages': loadConversations(); break;
                case 'profile':
                    loadProfileContent(param || auth.currentUser.uid);
                    break;
                case 'reels': showReels(); break;
                case 'reelsSearch': loadReelsSearchPage(); break; // New case
                case 'followers': loadFollowersPage(param); break;
                case 'following': loadFollowingPage(param); break;
                case 'settings': loadSettingsPage(); break;
                case 'privacySettings': loadPrivacySettingsPage(); break; 
                case 'swavotiVerification': loadSwavotiVerificationPage(); break; // New case
                case 'search': loadSearchPage(searchFilter); break;
                case 'manageMedia': loadMediaManagement(); break;
                default: if(auth.currentUser) navigateToPage('home');
            }
        }

        async function loadSwavotiVerificationPage() {
            if (!auth.currentUser) {
                navigateToPage('login');
                return;
            }

            if(verificationStatusContainer) {
                 verificationStatusContainer.innerHTML = '<div class="loading-spinner-container"><div class="loading-spinner"></div></div>';
            } else {
                console.error("Verification status container not found");
                return;
            }

            try {
                const userDoc = await db.collection('users').doc(auth.currentUser.uid).get();
                if (!userDoc.exists) {
                    verificationStatusContainer.innerHTML = '<p class="auth-error">User data not found.</p>';
                    return;
                }

                const userData = userDoc.data();
                const verificationStatus = userData.verificationStatus || 'not_verified';

                // This function will now be responsible for building the entire page structure
                renderVerificationPageLayout(verificationStatus);

            } catch (error) {
                console.error("Error loading verification status: ", error);
                if(verificationStatusContainer) {
                    verificationStatusContainer.innerHTML = '<p class="auth-error">Could not load verification status. Please try again.</p>';
                }
            }
        }

        function addVerificationPageEventListeners() {
            const applyBtn = document.getElementById('applyForVerificationBtn');

            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    applyVerificationIframe.src = 'https://ngysamusicdistribution.fillout.com/t/rtrfrQVnvEus';
                    applyVerificationIframeModal.style.display = 'flex';
                });
            }
        }

        window.addEventListener('hashchange', handleHashChange);

        document.querySelectorAll('.nav-link, .nav-icon').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const pageId = this.getAttribute('data-page');
                const param = pageId === 'profile' ? auth.currentUser.uid : null;
                navigateToPage(pageId, param);
            });
        });

        notificationIcon.addEventListener('click', (e) => { e.preventDefault(); navigateToPage('notifications'); });
        messageIcon.addEventListener('click', (e) => { e.preventDefault(); navigateToPage('messages'); });
        searchIconMobile.addEventListener('click', (e) => { e.preventDefault(); navigateToPage('search'); });


        const createPostModal = document.getElementById('createPostModal');
        const closeModal = document.getElementById('closeModal');
        const createPostStep1Div = document.getElementById('createPostStep1');
        const createPostStep2Div = document.getElementById('createPostStep2');
        const postNextBtn = document.getElementById('postNextBtn');
        const postBackBtn = document.getElementById('postBackBtn');
        const postSubmitBtn = document.getElementById('postSubmitBtn'); // Final submit
        const scheduleDateTimeInput = document.getElementById('scheduleDateTime');
        const clearScheduleBtn = document.getElementById('clearScheduleBtn');


        function openCreatePostModal() {
            createPostModal.style.display = 'flex';
            // Reset to step 1
            createPostStep1Div.style.display = 'block';
            createPostStep2Div.style.display = 'none';

            // Clear form fields and previews
            document.getElementById('postForm').reset();
            clearMediaAndPreview();
            tagsDisplay.innerHTML = '';
            currentTags = [];

            // Set defaults for Step 1
            postTypeSelect.value = 'post'; // Default to standard post
            // Update UI based on default post type for step 2 (though it's hidden)
            monetizationOptions.style.display = 'block';
            enableMonetizationCheckbox.checked = false;

            // Ensure "Next" button state is correct
            const hasText = document.getElementById('postText').value.trim().length > 0;
            const hasMedia = currentMediaFiles.length > 0;
            postNextBtn.classList.toggle('active', hasText || hasMedia);
            postNextBtn.disabled = !(hasText || hasMedia);

             // Ensure "Post Now" button in step 2 is initially not disabled for text-only posts
            postSubmitBtn.disabled = false;
            postSubmitBtn.textContent = 'Post Now';
        }

        document.getElementById('createPostBtn').addEventListener('click', openCreatePostModal);
        document.getElementById('mobileCreatePostBtn').addEventListener('click', (e) => {
            e.preventDefault();
            openCreatePostModal();
        });

        closeModal.addEventListener('click', () => {
            createPostModal.style.display = 'none';
        });

        postNextBtn.addEventListener('click', () => {
            const text = document.getElementById('postText').value.trim();
            const type = postTypeSelect.value;

            if (!text && currentMediaFiles.length === 0) {
                 showNotification("Please add content or media before proceeding.", "info");
                 return;
            }
            if (type === 'reel' && (currentMediaFiles.length === 0 || currentMediaFiles[0].type !== 'video')) {
                showNotification("Reels must be videos. Please select a video.", "error");
                return;
            }
            if (type === 'story' && (currentMediaFiles.length === 0 || currentMediaFiles[0].type !== 'image' || currentMediaFiles.length > 1)) {
                showNotification("Stories must be single images. Please select one image.", "error");
                return;
            }
            if (type === 'post' && currentMediaFiles.length > 0 && currentMediaFiles[0].type === 'video' && currentMediaFiles.length > 1) {
                showNotification("You can only upload one video per post. For multiple images, ensure all files are images.", "error");
                return;
            }


            createPostStep1Div.style.display = 'none';
            createPostStep2Div.style.display = 'block';

            if (postTypeSelect.value === 'post') {
                monetizationOptions.style.display = 'block';
            } else {
                monetizationOptions.style.display = 'none';
                enableMonetizationCheckbox.checked = false;
            }
            // Update the text of the final submit button based on schedule
            postSubmitBtn.textContent = scheduleDateTimeInput.value ? 'Schedule Post' : 'Post Now';
        });

        postBackBtn.addEventListener('click', () => {
            createPostStep2Div.style.display = 'none';
            createPostStep1Div.style.display = 'block';
        });

        clearScheduleBtn.addEventListener('click', () => {
            scheduleDateTimeInput.value = '';
            postSubmitBtn.textContent = 'Post Now'; // Update button text
        });
        scheduleDateTimeInput.addEventListener('change', () => {
            postSubmitBtn.textContent = scheduleDateTimeInput.value ? 'Schedule Post' : 'Post Now';
        });

        document.querySelectorAll('.profile-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.profile-tab').forEach(item => item.classList.remove('active'));
                this.classList.add('active');
                const tabName = this.getAttribute('data-tab');
                loadProfileContent(currentProfileUserId, tabName);
            });
        });

        document.querySelectorAll('.explore-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.getAttribute('data-explore-tab');
                loadExploreContent(tabName);
            });
        });

        async function openEditProfileModal(isSetup = false) {
            const user = auth.currentUser;
            if (!user) return;

            const userData = await getUserData(user.uid);

            isFirstTimeSetup = isSetup;

            if (!isFirstTimeSetup) {
                const lastEditFirebaseTimestamp = userData.lastProfileEditTimestamp;

                if (lastEditFirebaseTimestamp) {
                    const lastEditDate = lastEditFirebaseTimestamp.toDate(); // Convert to JS Date
                    const now = new Date();
                    const seventyTwoHoursInMs = 3 * 24 * 60 * 60 * 1000;

                    // Check if (current time - last edit time) < 72 hours
                    if ((now.getTime() - lastEditDate.getTime()) < seventyTwoHoursInMs) {
                        showNotification('You can only edit your profile every 3 days.', 'info');
                        return;
                    }
                }
                // If lastEditFirebaseTimestamp is null, the check is bypassed, allowing edit.
            }

            editNameInput.value = userData.name || '';
            editTitleInput.value = userData.title || '';
            editBioInput.value = userData.bio || '';
            editProfilePicPreview.src = userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png';
            newProfilePicFile = null;

            skipNameEdit.style.display = isFirstTimeSetup ? 'none' : 'block';
            prevProfilePicEdit.style.display = isFirstTimeSetup ? 'none' : 'block';
            closeEditProfileModal.style.display = isFirstTimeSetup ? 'none' : 'block';

            currentEditProfileStep = 1;
            showEditProfileStep(currentEditProfileStep);
            editProfileModal.style.display = 'flex';
        }

        function showEditProfileStep(step) {
            document.querySelectorAll('.edit-profile-step').forEach(s => s.classList.remove('active'));
            document.getElementById(`editProfileStep${step}`).classList.add('active');
            currentEditProfileStep = step;
        }

        closeEditProfileModal.addEventListener('click', () => editProfileModal.style.display = 'none');

        skipNameEdit.addEventListener('click', () => showEditProfileStep(2));
        saveNameEdit.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) return;
            const newName = editNameInput.value.trim();
            const newTitle = editTitleInput.value.trim();
            const newBio = editBioInput.value.trim();

            try {
                await db.collection('users').doc(user.uid).update({
                    name: newName,
                    title: newTitle,
                    bio: newBio,
                    lastProfileEditTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                delete userCache[user.uid];
                showEditProfileStep(2);
            } catch (error) {
                showNotification('Failed to update personal info.', 'error');
            }
        });

        uploadProfilePicBtn.addEventListener('click', () => editProfilePicUpload.click());
        editProfilePicUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                newProfilePicFile = file;
                editProfilePicPreview.src = URL.createObjectURL(file);
            }
        });

        prevProfilePicEdit.addEventListener('click', () => showEditProfileStep(1));
        saveProfilePicEdit.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) return;

            let updatePromises = [];

            if (newProfilePicFile) {
                try {
                    const imageUrl = await uploadFile(newProfilePicFile);
                    updatePromises.push(db.collection('users').doc(user.uid).update({ profilePicUrl: imageUrl }));
                } catch (error) {
                    showNotification('Failed to upload profile picture.', 'error');
                    return;
                }
            }

            const commonUpdateData = {
                lastProfileEditTimestamp: firebase.firestore.FieldValue.serverTimestamp()
            };
            if (isFirstTimeSetup) {
                commonUpdateData.isProfileSetupComplete = true;
            }
            updatePromises.push(db.collection('users').doc(user.uid).update(commonUpdateData));

            try {
                await Promise.all(updatePromises);
                delete userCache[user.uid];

                editProfileModal.style.display = 'none';
                loadCurrentUserData();
                loadProfileContent(user.uid);
                showNotification("Profile updated!", "success");

                if (isFirstTimeSetup) {
                    isFirstTimeSetup = false;
                    document.getElementById('contentArea').style.display = 'flex';
                    document.querySelector('.sidebar').style.display = '';
                    bottomNav.style.display = 'flex';
                    navigateToPage('home');
                }

            } catch (error) {
                showNotification('Failed to update profile.', 'error');
            }
        });


        async function openShareModal(id = null, type = 'profile') {
            let shareUrl;
            if (type === 'profile') {
                shareUrl = `${window.location.origin}${window.location.pathname}#profile/${id || auth.currentUser.uid}`;
            } else {
                shareUrl = `${window.location.origin}${window.location.pathname}#home/${id}`;
            }

            shareModal.style.display = 'flex';

            shareWhatsappBtn.onclick = () => window.open(`https://api.whatsapp.com/send?text=${encodeURIComponent(shareUrl)}`, '_blank');
            shareFacebookBtn.onclick = () => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}`, '_blank');
            copyLinkBtn.onclick = () => {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    showNotification('Link copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Failed to copy link.', 'error');
                });
            };

            const shareUserList = document.getElementById('shareUserList');
            shareUserList.innerHTML = '<div class="loading-spinner-container"><div class="loading-spinner"></div></div>';

            try {
                const currentUserData = await getUserData(auth.currentUser.uid);
                const followingIds = currentUserData.following || [];

                if (followingIds.length === 0) {
                    shareUserList.innerHTML = '<p style="color:var(--gray-color); text-align:center;">You are not following anyone.</p>';
                    return;
                }

                shareUserList.innerHTML = ''; // Clear loader
                for (const userId of followingIds) {
                    const userData = await getUserData(userId);
                    if (userData) {
                        const userItem = document.createElement('div');
                        userItem.className = 'user-list-item';
                        userItem.innerHTML = `
                            <img src="${userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`}" alt="User" style="width: 40px; height: 40px;">
                            <div class="user-list-info">
                                <h4>${userData.name}</h4>
                                <p>@${userData.username}</p>
                            </div>
                            <button class="profile-btn secondary-btn send-to-user-btn" data-user-id="${userData.uid}">Send</button>
                        `;
                        shareUserList.appendChild(userItem);
                    }
                }

                document.querySelectorAll('.send-to-user-btn').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const targetUserId = e.currentTarget.dataset.userId;
                        const messageText = `Check out this post: ${shareUrl}`;

                        // Re-use existing conversation logic
                        await startNewConversation(targetUserId);

                        // Send the message after conversation is opened/created
                        setTimeout(async () => {
                             if (currentChatConversationId) {
                                await db.collection('conversations').doc(currentChatConversationId).collection('messages').add({
                                    senderId: auth.currentUser.uid,
                                    text: messageText,
                                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                    read: false
                                });
                                await db.collection('conversations').doc(currentChatConversationId).update({
                                    lastMessage: { text: messageText, senderId: auth.currentUser.uid, timestamp: firebase.firestore.FieldValue.serverTimestamp(), read: false }
                                });
                                showNotification("Post sent!", "success");
                                closeShareModal.click();
                            }
                        }, 500); // Small delay to ensure conversation context is set
                    });
                });

            } catch (error) {
                console.error("Error loading users to share:", error);
                shareUserList.innerHTML = '<p class="auth-error">Could not load users.</p>';
            }
        }

        closeShareModal.addEventListener('click', () => shareModal.style.display = 'none');

        let currentEditingPostId = null; // To track which post is being edited

        async function openEditPostModal(postId) {
            const modal = document.getElementById('editPostModal');
            const postDoc = await db.collection('posts').doc(postId).get();
            if (!postDoc.exists) {
                showNotification("Error: Post not found.", "error");
                return;
            }
            const postData = postDoc.data();

            document.getElementById('editPostText').value = postData.content;
            currentEditingPostId = postId;
            modal.style.display = 'flex';
        }

        document.getElementById('closeEditPostModal')?.addEventListener('click', () => {
            document.getElementById('editPostModal').style.display = 'none';
            currentEditingPostId = null;
        });

        document.getElementById('editPostForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!currentEditingPostId) return;

            const newContent = document.getElementById('editPostText').value;
            try {
                await db.collection('posts').doc(currentEditingPostId).update({
                    content: newContent,
                    editedAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Update the UI directly
                const postElement = document.getElementById(`post-${currentEditingPostId}`);
                if (postElement) {
                    const postTextElement = postElement.querySelector('.post-text');
                    if (postTextElement) postTextElement.textContent = newContent;
                }

                showNotification("Post updated successfully!", "success");
                document.getElementById('editPostModal').style.display = 'none';
                currentEditingPostId = null;
            } catch (error) {
                showNotification("Failed to update post.", "error");
            }
        });

        async function openPostOptionsModal(postId) {
            const modal = document.getElementById('postOptionsModal');
            const content = document.getElementById('postOptionsModalContent');

            content.innerHTML = '<div class="loading-spinner-container"><div class="loading-spinner"></div></div>';
            modal.style.display = 'flex';

            const postDoc = await db.collection('posts').doc(postId).get();
            if (!postDoc.exists) {
                showNotification("Error: Post not found.", "error");
                modal.style.display = 'none';
                return;
            }
            const postData = postDoc.data();
            const authorId = postData.userId;
            const isOwnPost = auth.currentUser && auth.currentUser.uid === authorId;

            content.innerHTML = ''; // Clear previous options

            const options = [
                { text: 'Copy Link', icon: 'fa-copy', action: () => {
                    const postUrl = `${window.location.origin}${window.location.pathname}#home/${postId}`;
                    navigator.clipboard.writeText(postUrl).then(() => showNotification('Link copied!', 'success'));
                    modal.style.display = 'none';
                }}
            ];

            if (isOwnPost) {
                options.push({ text: 'Edit Post', icon: 'fa-edit', action: () => { openEditPostModal(postId); modal.style.display = 'none'; } });
                options.push({ text: 'Delete Post', icon: 'fa-trash-alt', danger: true, action: () => { deletePost(postId, document.getElementById(`post-${postId}`)); modal.style.display = 'none'; } });
            } else {
                options.push({ text: 'Report Post', icon: 'fa-flag', danger: true, action: () => { reportPost(postId); modal.style.display = 'none'; } });
                options.push({ text: 'Hide Post', icon: 'fa-eye-slash', action: () => {
                    document.getElementById(`post-${postId}`).style.display = 'none';
                    showNotification("Post hidden.", "info");
                    modal.style.display = 'none';
                }});
            }

            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = `settings-btn ${opt.danger ? 'danger' : ''}`;
                btn.innerHTML = `<i class="fas ${opt.icon}"></i> <span>${opt.text}</span>`;
                btn.onclick = opt.action;
                content.appendChild(btn);
            });

            modal.style.display = 'flex';

            // Close modal when clicking outside of the content
            modal.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = "none";
                }
            };
        }

        function openNotificationOptionsModal(notificationId) {
            const modal = document.getElementById('notificationOptionsModal');
            const content = document.getElementById('notificationOptionsModalContent');
            content.innerHTML = ''; // Clear previous options

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'settings-btn danger';
            deleteBtn.innerHTML = `<i class="fas fa-trash-alt"></i> <span>Delete Notification</span>`;
            deleteBtn.onclick = () => {
                deleteNotification(notificationId);
                modal.style.display = 'none';
            };
            content.appendChild(deleteBtn);

            modal.style.display = 'flex';
            modal.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = "none";
                }
            };
        }

        async function deleteNotification(notificationId) {
            try {
                await db.collection('notifications').doc(notificationId).delete();
                showNotification("Notification deleted.", "success");
                // The onSnapshot listener in loadNotifications will automatically remove it from the UI.
            } catch (error) {
                showNotification("Failed to delete notification.", "error");
            }
        }

        async function loadSettingsPage() {
            const user = auth.currentUser;
            if (!user) return;

            const userDocRef = db.collection('users').doc(user.uid);
            try {
                const doc = await userDocRef.get();
                if (doc.exists) {
                    const settings = doc.data().privacySettings || {};
                    privacyOnlineStatusSelect.value = settings.onlineStatusVisibility || 'everyone';
                    privacyStoryVisibilitySelect.value = settings.storyVisibility || 'everyone';
                    privacyCommentPermissionsSelect.value = settings.commentPermissions || 'everyone';
                    privacyAccountTypeSelect.value = doc.data().accountType || 'public'; // accountType might be at root
                } else {
                    // Set defaults if no settings found
                    privacyOnlineStatusSelect.value = 'everyone';
                    privacyStoryVisibilitySelect.value = 'everyone';
                    privacyCommentPermissionsSelect.value = 'everyone';
                    privacyAccountTypeSelect.value = 'public';
                }
            } catch (error) {
                console.error("Error loading privacy settings: ", error);
                showNotification("Could not load privacy settings.", "error");
            }
        }

        async function savePrivacySetting(key, value) {
            const user = auth.currentUser;
            if (!user) return;
            const userDocRef = db.collection('users').doc(user.uid);
            try {
                // For accountType, update at root. For others, update within privacySettings map.
                if (key === 'accountType') {
                    await userDocRef.update({ [key]: value });
                } else {
                    await userDocRef.set({
                        privacySettings: { [key]: value }
                    }, { merge: true });
                }
                delete userCache[user.uid]; // Invalidate cache
                showNotification("Privacy setting saved!", "success");
            } catch (error) {
                console.error("Error saving privacy setting: ", error);
                showNotification("Failed to save setting.", "error");
            }
        }

        privacyOnlineStatusSelect.addEventListener('change', (e) => savePrivacySetting('onlineStatusVisibility', e.target.value));
        privacyStoryVisibilitySelect.addEventListener('change', (e) => savePrivacySetting('storyVisibility', e.target.value));
        privacyCommentPermissionsSelect.addEventListener('change', (e) => savePrivacySetting('commentPermissions', e.target.value));
        privacyAccountTypeSelect.addEventListener('change', (e) => savePrivacySetting('accountType', e.target.value));


        logoutBtn.addEventListener('click', () => {
            showConfirmation('Are you sure you want to log out?', async () => {
                try {
                    const user = auth.currentUser;
                    if (user) {
                        await db.collection('users').doc(user.uid).update({ onlineStatus: false });
                    }
                    await auth.signOut();
                    showNotification('Logged out successfully!', 'success');
                    navigateToPage('login');
                } catch (error) {
                    showNotification('Failed to log out.', 'error');
                }
            });
        });

        shareProfileBtnSettings.addEventListener('click', () => openShareModal(null, 'profile'));
        accountSettingsBtn.addEventListener('click', openAccountSettingsModal);
        privacySettingsBtn.addEventListener('click', () => navigateToPage('privacySettings'));
        appSettingsBtn.addEventListener('click', openAppSettingsModal);
        swavotiVerificationBtn.addEventListener('click', () => navigateToPage('swavotiVerification')); // Navigate to new page
        // Original moreSettingsBtn is hidden, so its listener might not be needed or can be removed if the element is gone.
        // moreSettingsBtn.addEventListener('click', () => showNotification("More settings coming soon!", "info"));

        downloadDataBtn.addEventListener('click', () => {
            showNotification("Feature to download your data is coming soon!", "info");
        });
        legalBtn.addEventListener('click', () => {
            // For now, just a notification. Could navigate to a #/legal page later.
            showNotification("Legal information will be available here soon.", "info");
        });


        privacySettingsBackBtn.addEventListener('click', () => navigateToPage('settings'));

        // Remove old openVerificationModal and its close button listener
        // openVerificationModal function is removed.
        // closeVerificationModalBtn listener is removed.
        if (closeApplyVerificationIframe) { // New close button for the iframe modal
            closeApplyVerificationIframe.addEventListener('click', async () => {
                applyVerificationIframeModal.style.display = 'none';
                applyVerificationIframe.src = 'about:blank'; // Clear iframe

                // Update status to 'pending' in Firestore
                if (auth.currentUser) {
                    try {
                        await db.collection('users').doc(auth.currentUser.uid).update({
                            verificationStatus: 'pending',
                            verificationAppliedAt: firebase.firestore.FieldValue.serverTimestamp() // Optional: track application time
                        });
                        showNotification("Application submitted. Status is now pending.", "success");
                        // No need to manually call loadSwavotiVerificationPage if on the page,
                        // as onSnapshot for user data (if implemented) would update it.
                        // However, for explicit refresh if not using realtime listener for this specific page:
                        if (window.location.hash === '#swavotiVerification') {
                            loadSwavotiVerificationPage();
                        }
                    } catch (error) {
                        console.error("Error updating verification status to pending: ", error);
                        showNotification("Could not update verification status. Please try again.", "error");
                    }
                }
            });
        }


        async function loadPrivacySettingsPage() {
            // This function is very similar to loadSettingsPage but specific to privacy controls
            // It might be merged or kept separate for clarity if settings pages diverge more.
            const user = auth.currentUser;
            if (!user) return;

            const userDocRef = db.collection('users').doc(user.uid);
            try {
                const doc = await userDocRef.get();
                if (doc.exists) {
                    const settings = doc.data().privacySettings || {};
                    const accountType = doc.data().accountType || 'public';

                    privacyOnlineStatusSelect.value = settings.onlineStatusVisibility || 'everyone';
                    privacyStoryVisibilitySelect.value = settings.storyVisibility || 'everyone';
                    privacyCommentPermissionsSelect.value = settings.commentPermissions || 'everyone';
                    privacyAccountTypeSelect.value = accountType;
                } else {
                    // Set defaults if no settings found
                    privacyOnlineStatusSelect.value = 'everyone';
                    privacyStoryVisibilitySelect.value = 'everyone';
                    privacyCommentPermissionsSelect.value = 'everyone';
                    privacyAccountTypeSelect.value = 'public';
                }
            } catch (error) {
                console.error("Error loading privacy settings: ", error);
                showNotification("Could not load privacy settings.", "error");
                 // Set defaults on error
                privacyOnlineStatusSelect.value = 'everyone';
                privacyStoryVisibilitySelect.value = 'everyone';
                privacyCommentPermissionsSelect.value = 'everyone';
                privacyAccountTypeSelect.value = 'public';
            }
        }


        async function openAccountSettingsModal() {
            const user = auth.currentUser;
            if (!user) return;

            const userData = await getUserData(user.uid);
            if (!userData) return;

            accountSettingsAvatar.src = userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png';
            accountSettingsName.textContent = userData.name;
            accountSettingsEmail.textContent = userData.email;
            accountSettingsBalance.textContent = 'ZAR 0.00';

            onlineStatusToggle.checked = userData.onlineStatus === undefined ? true : userData.onlineStatus;
            readReceiptsToggle.checked = userData.readReceipts === undefined ? true : userData.readReceipts;

            // Initialize Dark Theme Toggle
            const darkThemeToggle = document.getElementById('darkThemeToggle');
            const currentTheme = localStorage.getItem('theme') || 'light';
            darkThemeToggle.checked = currentTheme === 'dark';
            document.body.classList.toggle('dark-theme', currentTheme === 'dark');


            accountSettingsModal.style.display = 'flex';
        }

        closeAccountSettingsModal.addEventListener('click', () => accountSettingsModal.style.display = 'none');

        // Event Listeners for new Account Settings options
        document.getElementById('blockedUsersBtn')?.addEventListener('click', () => {
            showNotification("Blocked Users management coming soon!", "info");
            // Future: navigateToPage('blockedUsers');
        });

        document.getElementById('notificationPreferencesBtn')?.addEventListener('click', () => {
            navigateToPage('privacySettings');
            closeAccountSettingsModal.click(); // Close the current modal
        });

        document.getElementById('darkThemeToggle')?.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.body.classList.add('dark-theme');
                localStorage.setItem('theme', 'dark');
                showNotification("Dark theme enabled.", "success");
            } else {
                document.body.classList.remove('dark-theme');
                localStorage.setItem('theme', 'light');
                showNotification("Light theme enabled.", "success");
            }
            // TODO: Add actual .dark-theme CSS styles for various components
        });


        resetPasswordBtn.addEventListener('click', () => {
            showConfirmation('A password reset email will be sent to your registered email address. Do you want to proceed?', async () => {
                try {
                    await auth.sendPasswordResetEmail(auth.currentUser.email);
                    showNotification('Password reset email sent!', 'success');
                }
                catch (error) {
                    showNotification('Failed to send password reset email. Please try again.', 'error');
                }
            });
        });

        changeEmailBtn.addEventListener('click', () => {
            showConfirmation('Changing your email requires re-authentication. You will be logged out. Do you want to proceed?', async () => {
                const newEmail = prompt("Please enter your new email address:");
                if (newEmail && newEmail.trim() !== '') {
                    try {
                        await auth.currentUser.updateEmail(newEmail.trim());
                        await db.collection('users').doc(auth.currentUser.uid).update({ email: newEmail.trim() });
                        delete userCache[auth.currentUser.uid];
                        showNotification('Email updated successfully! Please log in with your new email.', 'success');
                        await auth.signOut();
                    }
                    catch (error) {
                        showNotification(`Failed to change email: ${error.message}`, 'error');
                    }
                } else {
                    showNotification('Email change cancelled.', 'info');
                }
            });
        });

        onlineStatusToggle.addEventListener('change', async (e) => {
            const user = auth.currentUser;
            if (!user) return;
            try {
                await db.collection('users').doc(user.uid).update({ onlineStatus: e.target.checked });
                delete userCache[user.uid];
                showNotification(`Online status set to ${e.target.checked ? 'Online' : 'Offline'}.`, 'success');
            } catch (error) {
                showNotification('Failed to update online status.', 'error');
            }
        });

        readReceiptsToggle.addEventListener('change', async (e) => {
            const user = auth.currentUser;
            if (!user) return;
            try {
                await db.collection('users').doc(user.uid).update({ readReceipts: e.target.checked });
                delete userCache[user.uid];
                showNotification(`Read receipts set to ${e.target.checked ? 'On' : 'Off'}.`, 'success');
            } catch (error) {
                showNotification('Failed to update read receipts.', 'error');
            }
        });


        function openAppSettingsModal() {
            appSettingsModal.style.display = 'flex';
        }

        closeAppSettingsModal.addEventListener('click', () => appSettingsModal.style.display = 'none');

        document.getElementById('clearCacheBtn')?.addEventListener('click', () => {
            showConfirmation('Are you sure you want to clear the cache? This will remove locally stored data but will not affect your account.', () => {
                localStorage.clear();
                showNotification('Cache cleared successfully!', 'success');
            });
        });

        document.getElementById('sendFeedbackBtn')?.addEventListener('click', () => {
            document.getElementById('feedbackModal').style.display = 'flex';
        });

        document.getElementById('closeFeedbackModal')?.addEventListener('click', () => {
            document.getElementById('feedbackModal').style.display = 'none';
        });

        document.getElementById('feedbackForm')?.addEventListener('submit', (e) => {
            e.preventDefault();
            const feedbackText = document.getElementById('feedbackText').value;
            console.log("Feedback submitted:", feedbackText); // Placeholder action
            showNotification("Thank you for your feedback!", "success");
            document.getElementById('feedbackText').value = '';
            document.getElementById('feedbackModal').style.display = 'none';
        });

        async function openVerificationModal() {
            verificationModal.style.display = 'flex';
            // eligibilityCheck.style.display = 'block'; // Removed
            paymentPage.style.display = 'none';
            proceedVerificationBtn.style.display = 'block'; // Show by default now
            paymentError.textContent = '';

            // const user = auth.currentUser; // Still needed if there are other checks or for payment
            // if (!user) {
            //     // Handle not logged in state if necessary, e.g., disable button, show message
            //     proceedVerificationBtn.disabled = true;
            //     showNotification("Please log in to proceed with verification.", "info");
            //     return;
            // }
            // proceedVerificationBtn.disabled = false;
            // Any other logic that might depend on user data but not the explicit eligibility checks
        }

        closeVerificationModalBtn.addEventListener('click', () => verificationModal.style.display = 'none');

        proceedVerificationBtn.addEventListener('click', () => {
            // eligibilityCheck.style.display = 'none'; // Removed
            proceedVerificationBtn.style.display = 'none'; // Hide after clicking
            paymentPage.style.display = 'block';
            paymentError.textContent = '';
        });

        payNowBtn.addEventListener('click', () => {
            paymentError.textContent = 'Payment failed. Please try again later.';
            showNotification('Payment failed!', 'error');
        });

        let currentSupportedPostId = null;
        let currentCreatorId = null;

        function openSupportCreatorModal(postId, creatorId) {
            currentSupportedPostId = postId;
            currentCreatorId = creatorId;
            supportCreatorModal.style.display = 'flex';
        }

        closeSupportCreatorModal.addEventListener('click', () => {
            supportCreatorModal.style.display = 'none';
            currentSupportedPostId = null;
            currentCreatorId = null;
        });

        supportPriceButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const amount = e.currentTarget.dataset.amount;
                openPaymentModal(amount, currentSupportedPostId, currentCreatorId);
            });
        });

        function openPaymentModal(amount, postId, creatorId) {
            supportCreatorModal.style.display = 'none';
            paymentModal.style.display = 'flex';
            paymentAmountDisplay.textContent = `ZAR ${amount}.00`;
            paymentSupportError.textContent = '';

            payNowSupportBtn.onclick = () => {
                paymentSupportError.textContent = 'An error occurred. Please try again.';
                showNotification('Payment failed!', 'error');
            };
        }

        closePaymentModal.addEventListener('click', () => {
            paymentModal.style.display = 'none';
            paymentAmountDisplay.textContent = '';
            paymentSupportError.textContent = '';
        });


        function loadSearchPage(initialFilter = 'all') {
            searchResultsContainer.innerHTML = '';
            searchInput.value = '';
            currentSearchFilter = initialFilter;
            searchFilterButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === initialFilter) btn.classList.add('active');
            });
            searchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Start typing to search...</p>';

            if (searchInput.value.trim() && initialFilter !== 'all') {
                performSearch(searchInput.value.trim(), initialFilter);
            }
        }

        searchInput.addEventListener('input', () => {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                performSearch(searchInput.value.trim(), currentSearchFilter);
            }, 500);
        });

        searchFilterButtons.forEach(button => {
            button.addEventListener('click', () => {
                searchFilterButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentSearchFilter = button.dataset.filter;
                performSearch(searchInput.value.trim(), currentSearchFilter);
            });
        });

        async function performSearch(query, filter) {
            searchResultsContainer.innerHTML = '';
            if (!query) {
                searchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Start typing to search...</p>';
                return;
            }
            // Show spinner instead of skeleton loader
            searchResultsContainer.innerHTML = '<div class="loading-spinner-container"><div class="loading-spinner"></div></div>';

            const lowerCaseQuery = query.toLowerCase();
            let results = [];

            try {
                if (filter === 'all' || filter === 'posts') {
                    const postsSnapshot = await db.collection('posts')
                        .where('type', '==', 'post')
                        .get();
                    postsSnapshot.forEach(doc => {
                        const post = doc.data();
                        if ((post.content && post.content.toLowerCase().includes(lowerCaseQuery)) ||
                            (post.tags && post.tags.some(tag => tag.toLowerCase().includes(lowerCaseQuery)))) {
                            results.push({ id: doc.id, type: 'post', data: post });
                        }
                    });
                }
                if (filter === 'all' || filter === 'reels') {
                    const reelsSnapshot = await db.collection('posts')
                        .where('type', '==', 'reel')
                        .get();
                    reelsSnapshot.forEach(doc => {
                        const reel = doc.data();
                        if ((reel.content && reel.content.toLowerCase().includes(lowerCaseQuery)) ||
                            (reel.tags && reel.tags.some(tag => tag.toLowerCase().includes(lowerCaseQuery)))) {
                            results.push({ id: doc.id, type: 'reel', data: reel });
                        }
                    });
                }
                if (filter === 'all' || filter === 'users') {
                    const usersSnapshot = await db.collection('users').get();
                    usersSnapshot.forEach(doc => {
                        const user = {...doc.data(), uid: doc.id};
                        if ((user.name && user.name.toLowerCase().includes(lowerCaseQuery)) ||
                            (user.username && user.username.toLowerCase().includes(lowerCaseQuery))) {
                            results.push({ id: doc.id, type: 'user', data: user });
                        }
                    });
                }
                // Tags filter logic removed as the button is gone.
                // if (filter === 'tags') {
                //     const postsAndReelsSnapshot = await db.collection('posts').get();
                //     postsAndReelsSnapshot.forEach(doc => {
                //         const item = doc.data();
                //         if (item.tags && item.tags.some(tag => tag.toLowerCase() === lowerCaseQuery)) {
                //             results.push({ id: doc.id, type: item.type, data: item });
                //         }
                //     });
                // }

                // Clear spinner before rendering results
                searchResultsContainer.innerHTML = '';
                if (results.length === 0) {
                    searchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No results found.</p>';
                } else {
                    results.sort((a, b) => {
                        if (a.data.timestamp && b.data.timestamp) {
                            return b.data.timestamp.toDate() - a.data.timestamp.toDate();
                        }
                        return 0;
                    });

                    for (const item of results) {
                        if (item.type === 'post') {
                            await renderPost(item.id, item.data, searchResultsContainer);
                        } else if (item.type === 'reel') {
                            await renderPost(item.id, item.data, searchResultsContainer);
                        } else if (item.type === 'user') {
                            renderUserResult(item.id, item.data, searchResultsContainer);
                        }
                    }
                }

            } catch (error) {
                // Clear spinner on error
                searchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Error searching.</p>';
            }
        }

        function renderUserResult(userId, userData, container) {
            const userCard = document.createElement('div');
            userCard.className = 'search-result-user-card';
            userCard.innerHTML = `
                <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="User" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 15px;">
                <div class="search-result-user-info">
                    <h4>${userData.name} ${userData.verified ? '<i class="fas fa-check-circle verified-badge"></i>' : ''}</h4>
                    <p>@${userData.username}</p>
                </div>
            `;
            userCard.addEventListener('click', () => navigateToPage('profile', userId));
            container.appendChild(userCard);
        }

        // Reels Search Page Specific Logic
        function loadReelsSearchPage() {
            reelsSearchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Search for amazing reels!</p>';
            reelsSearchInput.value = '';
            reelsSearchInput.focus();
        }

        reelsSearchBackBtn.addEventListener('click', () => {
            navigateToPage('reels'); // This will call showReels()
        });

        reelsSearchInput.addEventListener('input', () => {
            clearTimeout(reelsSearchDebounceTimer);
            reelsSearchDebounceTimer = setTimeout(() => {
                performReelsSearch(reelsSearchInput.value.trim());
            }, 500);
        });


        // User Mentions Functions
        function positionMentionsDropdown(inputElement) {
            if (!mentionsDropdown || !inputElement) return;
            const rect = inputElement.getBoundingClientRect();
            // Approximate caret position (very basic, might need a library for complex inputs)
            // For textareas, this is harder. For now, position below the input.
            mentionsDropdown.style.top = `${rect.bottom + window.scrollY}px`;
            mentionsDropdown.style.left = `${rect.left + window.scrollX}px`;
            mentionsDropdown.style.display = 'block';
            mentionsDropdown.style.width = `${inputElement.offsetWidth}px`; // Match width of input
        }

        async function searchUsersForMention(searchTerm) {
            if (!searchTerm || searchTerm.length < 1) { // Min 1 char after @
                mentionsDropdown.innerHTML = '';
                mentionsDropdown.style.display = 'none';
                return;
            }
            try {
                const usersRef = db.collection('users');
                // Simple prefix search. For more complex search, consider a dedicated search service.
                const querySnapshot = await usersRef
                                        .where('username', '>=', searchTerm)
                                        .where('username', '<=', searchTerm + '\uf8ff')
                                        .limit(5) // Limit results
                                        .get();

                mentionsDropdown.innerHTML = ''; // Clear previous results
                if (querySnapshot.empty) {
                    mentionsDropdown.style.display = 'none';
                    return;
                }

                querySnapshot.forEach(doc => {
                    const userData = doc.data();
                    const item = document.createElement('div');
                    item.className = 'mention-item';
                    item.innerHTML = `
                        <img src="${userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`}" alt="${userData.username}">
                        <span class="username">${userData.username}</span>
                        <span class="name">(${userData.name})</span>
                    `;
                    item.addEventListener('click', () => {
                        if (currentMentionInputTarget) {
                            const currentValue = currentMentionInputTarget.value;
                            const atIndex = currentValue.lastIndexOf('@', currentMentionInputTarget.selectionStart -1);
                            if (atIndex !== -1) {
                                const before = currentValue.substring(0, atIndex);
                                const after = currentValue.substring(currentMentionInputTarget.selectionStart);
                                currentMentionInputTarget.value = `${before}@${userData.username} ${after}`;
                                // Move cursor after the inserted mention
                                const newCursorPos = (before + `@${userData.username} `).length;
                                currentMentionInputTarget.focus();
                                currentMentionInputTarget.setSelectionRange(newCursorPos, newCursorPos);
                            }
                        }
                        mentionsDropdown.style.display = 'none';
                        mentionsDropdown.innerHTML = '';
                        currentMentionInputTarget = null;
                    });
                    mentionsDropdown.appendChild(item);
                });

                if (mentionsDropdown.children.length > 0) {
                    positionMentionsDropdown(currentMentionInputTarget);
                } else {
                    mentionsDropdown.style.display = 'none';
                }

            } catch (error) {
                console.error("Error searching users for mention: ", error);
                mentionsDropdown.style.display = 'none';
            }
        }

        function handleMentionInput(event) {
            currentMentionInputTarget = event.target;
            const text = currentMentionInputTarget.value;
            const cursorPos = currentMentionInputTarget.selectionStart;

            // Find the start of the potential mention
            let atIndex = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    atIndex = i;
                    break;
                }
                if (/\s/.test(text[i])) { // Stop if whitespace encountered before @
                    break;
                }
            }

            if (atIndex !== -1) {
                const mentionQuery = text.substring(atIndex + 1, cursorPos);
                // Basic validation: no spaces in mention query, allow alphanumeric and underscore
                if (/^[a-zA-Z0-9_]*$/.test(mentionQuery)) {
                    clearTimeout(mentionQueryDebounceTimer);
                    mentionQueryDebounceTimer = setTimeout(() => {
                        searchUsersForMention(mentionQuery);
                    }, 300); // Debounce API calls
                } else {
                    mentionsDropdown.style.display = 'none'; // Hide if invalid chars in query
                }
            } else {
                mentionsDropdown.style.display = 'none';
            }
        }

        // Hide mentions dropdown if clicked outside
        document.addEventListener('click', function(event) {
            if (mentionsDropdown && !mentionsDropdown.contains(event.target) && currentMentionInputTarget && !currentMentionInputTarget.contains(event.target)) {
                mentionsDropdown.style.display = 'none';
            }
        });

        // Attach mention handler to relevant inputs
        // Need to ensure these elements exist before adding listeners, e.g., after modal is shown or on page load
        // For now, will attach them directly. If issues arise, defer attachment.
        const mentionableInputsIds = ['postText', 'commentText', 'chatMessageInput', 'storyReplyInput']; // Add 'storyReplyInput'
        mentionableInputsIds.forEach(id => {
            const inputElement = document.getElementById(id);
            if (inputElement) {
                inputElement.addEventListener('input', handleMentionInput);
                inputElement.addEventListener('blur', () => {
                    // Small delay to allow click on dropdown item
                    setTimeout(() => {
                        if (!mentionsDropdown.matches(':hover')) { // Don't hide if mouse is over dropdown
                           mentionsDropdown.style.display = 'none';
                        }
                    }, 150);
                });
                 inputElement.addEventListener('keydown', (e) => { // Hide on Escape
                    if (e.key === 'Escape') {
                        mentionsDropdown.style.display = 'none';
                    }
                });
            }
        });


        async function performReelsSearch(query) {
            reelsSearchResultsContainer.innerHTML = '';
            if (!query) {
                reelsSearchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">Start typing to search reels.</p>';
                return;
            }
            showInlineLoader(reelsSearchResultsContainer, 'reel-grid-item', 6);

            const lowerCaseQuery = query.toLowerCase();
            let results = [];
            try {
                const reelsSnapshot = await db.collection('posts')
                    .where('type', '==', 'reel')
                    .get(); // Consider adding .orderBy().limit() for larger datasets

                reelsSnapshot.forEach(doc => {
                    const reel = doc.data();
                    if ((reel.content && reel.content.toLowerCase().includes(lowerCaseQuery)) ||
                        (reel.tags && reel.tags.some(tag => tag.toLowerCase().includes(lowerCaseQuery)))) {
                        results.push({ id: doc.id, data: reel });
                    }
                });

                hideInlineLoader(reelsSearchResultsContainer);
                reelsSearchResultsContainer.innerHTML = ''; // Clear again before rendering

                if (results.length === 0) {
                    reelsSearchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--gray-color);padding:20px;">No reels found for your search.</p>';
                } else {
                    results.sort((a, b) => b.data.timestamp.toDate() - a.data.timestamp.toDate()); // Sort by newest
                    for (const item of results) {
                        await renderExploreReelItem(item.id, item.data, reelsSearchResultsContainer);
                    }
                }
            } catch (error) {
                hideInlineLoader(reelsSearchResultsContainer);
                reelsSearchResultsContainer.innerHTML = '<p style="text-align:center;color:var(--danger-color);padding:20px;">Error searching reels. Please try again.</p>';
            }
        }

        // Suggested Users Feature
        function renderSuggestedUserCard(userData, container) {
            const card = document.createElement('div');
            card.className = 'suggested-user-card';
            card.dataset.userId = userData.uid;

            card.innerHTML = `
                <img src="${userData.profilePicUrl || 'https://img.icons8.com/liquid-glass/48/user.png'}" alt="${userData.username}" class="avatar">
                <span class="username">${userData.username}</span>
                <span class="name">${userData.name}</span>
                <button class="sugg-follow-btn primary-btn profile-btn">Follow</button> <!-- Reusing profile-btn for consistency -->
                <button class="sugg-remove-btn">Dismiss</button>
            `;

            const followBtn = card.querySelector('.sugg-follow-btn');
            followBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFollow(userData.uid, followBtn); // toggleFollow will handle text change to "Following"
            });

            const removeBtn = card.querySelector('.sugg-remove-btn');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                card.remove(); // Simple removal for now
                // TODO: Persist dismissal for the user
            });

            card.addEventListener('click', () => navigateToPage('profile', userData.uid));

            container.appendChild(card);
        }

        async function renderSuggestedUsersSection(feedContainer, currentUserData) {
            if (!currentUserData || !auth.currentUser) return;

            const suggestionsContainerId = 'suggested-users-section-' + Date.now(); // Unique ID if multiple sections
            if (document.getElementById(suggestionsContainerId)) return; // Avoid duplicate sections too quickly

            const container = document.createElement('div');
            container.className = 'suggested-users-container';
            container.id = suggestionsContainerId;
            container.innerHTML = `
                <div class="suggested-users-header">
                    <h4>Suggested Accounts</h4>
                    <!-- <a href="#" class="see-all-btn">See All</a> -->
                </div>
                <div class="suggested-users-scroll">
                    <!-- Suggested user cards will be appended here -->
                </div>
            `;

            const scrollArea = container.querySelector('.suggested-users-scroll');

            try {
                // Basic suggestion: Get some users, exclude current user and those already followed
                // This is a very naive implementation. Real suggestions would be more complex.
                const usersSnapshot = await db.collection('users').limit(10).get(); // Get more to filter from
                const suggestions = [];
                const following = currentUserData.following || [];

                for (const doc of usersSnapshot.docs) {
                    if (suggestions.length >= 4) break; // Max 4 suggestions
                    const userData = { uid: doc.id, ...doc.data() };
                    if (userData.uid !== auth.currentUser.uid && !following.includes(userData.uid)) {
                        // Further check: ensure this user isn't already shown in another suggestion block on this load
                        if(!document.querySelector(`.suggested-user-card[data-user-id="${userData.uid}"]`)) {
                           suggestions.push(userData);
                        }
                    }
                }

                if (suggestions.length > 0) {
                    suggestions.forEach(user => renderSuggestedUserCard(user, scrollArea));
                    feedContainer.appendChild(container); // Append to the main feed
                }
            } catch (error) {
                console.error("Error fetching suggested users:", error);
            }
        }
        // End Suggested Users Feature

        const addMoreImageBtn = document.getElementById('addMoreImageBtn');
        if (addMoreImageBtn) {
            addMoreImageBtn.addEventListener('click', () => {
                isAddingMoreImages = true;
                photoUpload.click(); // Open file dialog
            });
        }

        // New Group Modal Elements
        const newGroupModal = document.getElementById('newGroupModal');
        const closeNewGroupModal = document.getElementById('closeNewGroupModal');
        const newGroupBtn = document.getElementById('newGroupBtn'); // Button on messages page
        const newGroupStep1Div = document.getElementById('newGroupStep1');
        const newGroupStep2Div = document.getElementById('newGroupStep2');
        const newGroupModalTitle = document.getElementById('newGroupModalTitle');
        const newGroupUserList = document.getElementById('newGroupUserList');
        const newGroupMemberSearch = document.getElementById('newGroupMemberSearch');
        const newGroupNextBtn = document.getElementById('newGroupNextBtn');
        const newGroupBackBtn = document.getElementById('newGroupBackBtn');
        const newGroupNameInput = document.getElementById('newGroupName');
        const newGroupIconUpload = document.getElementById('newGroupIconUpload');
        const newGroupIconPreview = document.getElementById('newGroupIconPreview');
        const newGroupDescriptionInput = document.getElementById('newGroupDescription');
        const saveNewGroupBtn = document.getElementById('saveNewGroupBtn');

        let selectedGroupMembers = []; // To store UIDs of selected users
        let newGroupIconFile = null;

        // Function to open and reset the New Group Modal
        function openNewGroupModal() {
            selectedGroupMembers = [];
            newGroupIconFile = null;
            newGroupStep1Div.style.display = 'block';
            newGroupStep2Div.style.display = 'none';
            newGroupModalTitle.textContent = 'Create New Group - Select Members';
            newGroupNameInput.value = '';
            newGroupDescriptionInput.value = '';
            newGroupIconUpload.value = null; // Clear file input
            newGroupIconPreview.style.display = 'none';
            newGroupIconPreview.src = '#';
            newGroupUserList.innerHTML = '<p style="text-align:center; color: var(--gray-color);">Loading users you follow...</p>';
            newGroupMemberSearch.value = '';
            loadFollowedUsersForGroup(); // Load users for selection
            newGroupModal.style.display = 'flex';
        }

        // Function to close the New Group Modal
        function closeNewGroupModalFunc() {
            newGroupModal.style.display = 'none';
        }

        // Event Listeners for New Group Modal
        if (newGroupBtn) {
            newGroupBtn.addEventListener('click', openNewGroupModal);
        }
        if (closeNewGroupModal) {
            closeNewGroupModal.addEventListener('click', closeNewGroupModalFunc);
        }

        if (newGroupNextBtn) {
            newGroupNextBtn.addEventListener('click', () => {
                // Get selected users
                selectedGroupMembers = [];
                const checkboxes = newGroupUserList.querySelectorAll('input[type="checkbox"]:checked');
                checkboxes.forEach(checkbox => {
                    selectedGroupMembers.push(checkbox.value);
                });

                if (selectedGroupMembers.length === 0) {
                    showNotification("Please select at least one member for the group.", "info");
                    return;
                }

                newGroupStep1Div.style.display = 'none';
                newGroupStep2Div.style.display = 'block';
                newGroupModalTitle.textContent = 'Create New Group - Group Details';
            });
        }

        if (newGroupBackBtn) {
            newGroupBackBtn.addEventListener('click', () => {
                newGroupStep2Div.style.display = 'none';
                newGroupStep1Div.style.display = 'block';
                newGroupModalTitle.textContent = 'Create New Group - Select Members';
                // Users are already loaded and selections preserved in selectedGroupMembers
                // Re-render or re-check based on selectedGroupMembers if needed, but current approach keeps checkboxes state.
            });
        }

        if (newGroupIconUpload) {
            newGroupIconUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.match('image.*')) {
                    newGroupIconFile = file;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        newGroupIconPreview.src = event.target.result;
                        newGroupIconPreview.style.display = 'block';
                    }
                    reader.readAsDataURL(file);
                } else {
                    newGroupIconFile = null;
                    newGroupIconPreview.style.display = 'none';
                    newGroupIconPreview.src = '#';
                    if (file) { // if a file was selected but not an image
                        showNotification("Please select a valid image file for the group icon.", "error");
                    }
                }
            });
        }

        async function loadFollowedUsersForGroup(searchTerm = '') {
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            newGroupUserList.innerHTML = '<div class="loading-spinner-container"><div class="loader"></div></div>';

            try {
                const currentUserData = await getUserData(currentUser.uid);
                const followingIds = currentUserData.following || [];

                if (followingIds.length === 0) {
                    newGroupUserList.innerHTML = '<p style="text-align:center; color: var(--gray-color);">You are not following anyone to add to a group.</p>';
                    return;
                }

                const userPromises = followingIds.map(id => getUserData(id));
                const followedUsersData = (await Promise.all(userPromises)).filter(Boolean);

                newGroupUserList.innerHTML = ''; // Clear loader

                const lowerSearchTerm = searchTerm.toLowerCase();
                const filteredUsers = followedUsersData.filter(userData => {
                    const usernameMatch = userData.username && userData.username.toLowerCase().includes(lowerSearchTerm);
                    const nameMatch = userData.name && userData.name.toLowerCase().includes(lowerSearchTerm);
                    return usernameMatch || nameMatch;
                });

                if (filteredUsers.length === 0) {
                     newGroupUserList.innerHTML = `<p style="text-align:center; color: var(--gray-color);">${searchTerm ? 'No matching users found.' : 'No users to display.'}</p>`;
                     return;
                }

                filteredUsers.forEach(userData => {
                    const userItem = document.createElement('div');
                    userItem.className = 'user-list-item'; // Re-use existing style
                    userItem.style.padding = '10px';
                    userItem.style.borderBottom = '1px solid #f0f0f0';
                    userItem.innerHTML = `
                        <img src="${userData.profilePicUrl || `https://ui-avatars.com/api/?name=${getInitials(userData.name)}&background=random`}" alt="${userData.username}" style="width: 40px; height: 40px;">
                        <div class="user-list-info" style="flex-grow: 1;">
                            <h4>${userData.name} ${userData.verified ? '<i class="fas fa-shield-alt verified-badge"></i>' : ''}</h4>
                            <p>@${userData.username}</p>
                        </div>
                        <input type="checkbox" value="${userData.uid}" id="group-member-${userData.uid}" style="transform: scale(1.2); margin-left:10px;" ${selectedGroupMembers.includes(userData.uid) ? 'checked' : ''}>
                    `;
                    // Add click listener to toggle checkbox when clicking the item (optional)
                    userItem.addEventListener('click', (e) => {
                        if (e.target.type !== 'checkbox') {
                            const checkbox = userItem.querySelector('input[type="checkbox"]');
                            checkbox.checked = !checkbox.checked;
                        }
                    });
                    newGroupUserList.appendChild(userItem);
                });

            } catch (error) {
                console.error("Error loading followed users for group:", error);
                newGroupUserList.innerHTML = '<p style="text-align:center; color: var(--danger-color);">Could not load users.</p>';
            }
        }

        if (newGroupMemberSearch) {
            newGroupMemberSearch.addEventListener('input', () => {
                loadFollowedUsersForGroup(newGroupMemberSearch.value.trim());
            });
        }

        document.getElementById('conversationSearchInput')?.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const conversationItems = conversationsList.querySelectorAll('.message-item');
            conversationItems.forEach(item => {
                const partnerName = item.querySelector('h4').textContent.toLowerCase();
                if (partnerName.includes(searchTerm)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        });

        document.getElementById('mediaManagerBackBtn')?.addEventListener('click', () => navigateToPage('messages'));

        async function loadMediaManagement() {
            const mediaGrid = document.getElementById('mediaGridContainer');
            mediaGrid.innerHTML = '<div class="loading-spinner-container"><div class="loading-spinner"></div></div>';

            const user = auth.currentUser;
            if (!user) return;

            let allMedia = [];
            const conversationsSnapshot = await db.collection('conversations').where('participants', 'array-contains', user.uid).get();

            for (const convDoc of conversationsSnapshot.docs) {
                const messagesSnapshot = await convDoc.ref.collection('messages').where('mediaType', '==', 'image').get();
                messagesSnapshot.forEach(msgDoc => {
                    allMedia.push(msgDoc.data());
                });
            }

            mediaGrid.innerHTML = '';
            if (allMedia.length === 0) {
                mediaGrid.innerHTML = '<p>No media found in your conversations.</p>';
                return;
            }

            allMedia.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());

            allMedia.forEach(media => {
                const mediaItem = document.createElement('div');
                mediaItem.className = 'profile-grid-item';
                mediaItem.innerHTML = `
                    <img src="${media.mediaUrl}" style="width:100%; height:100%; object-fit:cover;">
                    <a href="${media.mediaUrl}" download="swavoti-media.jpg" class="profile-btn secondary-btn" style="position:absolute; bottom:5px; right:5px; padding: 5px 8px; font-size:12px;"><i class="fas fa-download"></i></a>
                `;
                mediaGrid.appendChild(mediaItem);
            });
        }

        // Placeholder for saveNewGroupBtn listener (will be more complex)
        if (saveNewGroupBtn) {
            saveNewGroupBtn.addEventListener('click', async () => {
                const groupName = newGroupNameInput.value.trim();
                const groupDescription = newGroupDescriptionInput.value.trim();
                const currentUser = auth.currentUser;

                if (!groupName) {
                    showNotification("Group name is required.", "error");
                    return;
                }
                if (!currentUser) {
                    showNotification("You must be logged in to create a group.", "error");
                    return;
                }
                if (selectedGroupMembers.length === 0) {
                    showNotification("Please select at least one member for the group (go back to Step 1).", "error");
                    // Potentially force back to step 1 or handle more gracefully
                    return;
                }

                saveNewGroupBtn.disabled = true;
                saveNewGroupBtn.innerHTML = '<i class="fas fa-spinner fa-spin" style="margin-right: 5px;"></i> Saving...';

                let iconUrl = null;
                if (newGroupIconFile) {
                    try {
                        iconUrl = await uploadFile(newGroupIconFile); // Assumes uploadFile uses Thumbsnap
                    } catch (error) {
                        showNotification("Failed to upload group icon. Group will be created without an icon.", "warning");
                        // Proceed without icon or allow user to retry? For now, proceed.
                    }
                }

                const groupData = {
                    name: groupName,
                    description: groupDescription,
                    iconUrl: iconUrl,
                    members: [...new Set([currentUser.uid, ...selectedGroupMembers])], // Ensure creator is a member and unique list
                    creatorId: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: null // Or some initial message
                };

                try {
                    await db.collection('groups').add(groupData);
                    showNotification(`Group "${groupName}" created successfully!`, "success");
                    closeNewGroupModalFunc();
                    // Optionally, switch to the 'Groups' filter and refresh the list
                    if (document.querySelector('.message-filter-btn[data-message-filter="groups"]')) {
                         document.querySelector('.message-filter-btn[data-message-filter="groups"]').click();
                    } else {
                        loadConversations(); // Fallback to refresh general conversations view
                    }
                } catch (error) {
                    console.error("Error creating group:", error);
                    showNotification("Failed to create group. Please try again.", "error");
                } finally {
                    saveNewGroupBtn.disabled = false;
                    saveNewGroupBtn.innerHTML = '<i class="fas fa-save" style="margin-right: 5px;"></i> Save Group';
                }
            });
        }

        // Function to set CSS variable for viewport height
        function setVhVariable() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        window.addEventListener('resize', setVhVariable);
        window.addEventListener('load', setVhVariable);
        setVhVariable(); // Initial call


    </script>
</body>
</html>